use crate::error::{ArcError, ArcResult};
use crate::route::common::AuthGuard;
use crate::route::{success_return, RouteResult};
use crate::service::download::DownloadService;
use crate::service::user::UserService;
use rocket::{get, routes, Route, State};
use serde_json::Value;

/// Download songs for authenticated user
///
/// This endpoint allows users to download song files. It supports both
/// getting file checksums and download URLs. When URLs are requested,
/// it enforces download rate limits.
///
/// Query Parameters:
/// - sid: List of song IDs to download (optional, defaults to all songs)
/// - url: Whether to include download URLs (optional, defaults to true)
///
/// Returns download information including file checksums and optionally URLs
#[get("/serve/download/me/song?<sid>&<url>")]
pub async fn download_song(
    user_auth: AuthGuard,
    download_service: &State<DownloadService>,
    user_service: &State<UserService>,
    sid: Option<Vec<String>>,
    url: Option<String>,
) -> RouteResult<Value> {
    // Parse the url parameter, default to true
    let include_urls = match url.as_deref() {
        Some("false") => false,
        Some("0") => false,
        _ => true,
    };

    // Get user information
    let user = user_service.get_user_info(user_auth.user_id).await?;

    // Generate download list
    let download_data = download_service
        .generate_download_list(&user, sid, include_urls)
        .await?;

    Ok(success_return(serde_json::json!(download_data)))
}

/// Handle download file request with token validation
///
/// This endpoint serves the actual file downloads after validating the download token.
/// It's called when users access the download URLs generated by the download_song endpoint.
///
/// Path Parameters:
/// - song_id: The song identifier
/// - file_name: The specific file to download
///
/// Query Parameters:
/// - t: Download token for validation
#[get("/download/<song_id>/<file_name>?<t>")]
pub async fn serve_download_file(
    download_service: &State<DownloadService>,
    song_id: String,
    file_name: String,
    t: String,
) -> ArcResult<Vec<u8>> {
    // Validate the download token
    let (_user_id, _token_time) = download_service
        .validate_download_token(&song_id, &file_name, &t)
        .await?;

    // Check if the file is available for download
    if !download_service.is_available_file(&song_id, &file_name) {
        return Err(ArcError::no_access(
            "File not available for download".to_string(),
            403,
        ));
    }

    // Read and return the file content
    let file_path = format!("./songs/{song_id}/{file_name}");
    match std::fs::read(&file_path) {
        Ok(content) => Ok(content),
        Err(_) => Err(ArcError::no_data("File not found".to_string(), 404)),
    }
}

/// Download routes
pub fn routes() -> Vec<Route> {
    routes![download_song, serve_download_file]
}
