use crate::error::{ArcError, ArcResult};
use crate::route::common::AuthGuard;
use crate::service::download::DownloadService;
use crate::service::user::UserService;
use rocket::serde::json::Json;
use rocket::{get, routes, Route, State};
use serde_json::Value;
use std::collections::HashMap;

/// Download routes
pub fn routes() -> Vec<Route> {
    routes![download_song]
}

/// Download songs for authenticated user
///
/// This endpoint allows users to download song files. It supports both
/// getting file checksums and download URLs. When URLs are requested,
/// it enforces download rate limits.
///
/// Query Parameters:
/// - sid: List of song IDs to download (optional, defaults to all songs)
/// - url: Whether to include download URLs (optional, defaults to true)
///
/// Returns download information including file checksums and optionally URLs
#[get("/serve/download/me/song?<sid>&<url>")]
pub async fn download_song(
    user_auth: AuthGuard,
    download_service: &State<DownloadService>,
    user_service: &State<UserService>,
    sid: Option<Vec<String>>,
    url: Option<String>,
) -> ArcResult<Json<HashMap<String, Value>>> {
    // Parse the url parameter, default to true
    let include_urls = match url.as_deref() {
        Some("false") => false,
        Some("0") => false,
        _ => true,
    };

    // Get user information
    let user = user_service.get_user_info(user_auth.user_id).await?;

    // Generate download list
    let download_data = download_service
        .generate_download_list(&user, sid, include_urls)
        .await?;

    // Convert to the expected JSON format
    let mut response = HashMap::new();
    response.insert("success".to_string(), Value::Bool(true));
    response.insert("value".to_string(), serde_json::to_value(download_data)?);

    Ok(Json(response))
}

/// Handle download file request with token validation
///
/// This endpoint serves the actual file downloads after validating the download token.
/// It's called when users access the download URLs generated by the download_song endpoint.
///
/// Path Parameters:
/// - song_id: The song identifier
/// - file_name: The specific file to download
///
/// Query Parameters:
/// - t: Download token for validation
#[get("/download/<song_id>/<file_name>?<t>")]
pub async fn serve_download_file(
    download_service: &State<DownloadService>,
    song_id: String,
    file_name: String,
    t: String,
) -> ArcResult<Vec<u8>> {
    // Validate the download token
    let (_user_id, _token_time) = download_service
        .validate_download_token(&song_id, &file_name, &t)
        .await?;

    // Check if the file is available for download
    if !download_service.is_available_file(&song_id, &file_name) {
        return Err(ArcError::no_access(
            "File not available for download".to_string(),
            403,
        ));
    }

    // Read and return the file content
    let file_path = format!("./songs/{}/{}", song_id, file_name);
    match std::fs::read(&file_path) {
        Ok(content) => Ok(content),
        Err(_) => Err(ArcError::no_data("File not found".to_string(), 404)),
    }
}

/// Get finale progress (world boss health bar)
///
/// This endpoint returns the current progress of the finale event.
/// Currently returns a fixed value of 100000 (100%).
#[get("/finale/progress")]
pub async fn finale_progress() -> ArcResult<Json<HashMap<String, Value>>> {
    let mut response = HashMap::new();
    response.insert("success".to_string(), Value::Bool(true));

    let mut value = HashMap::new();
    value.insert("percentage".to_string(), Value::Number(100000.into()));

    response.insert("value".to_string(), serde_json::to_value(value)?);

    Ok(Json(response))
}

/// Start finale event
///
/// This endpoint handles the finale event start request.
/// Currently returns a placeholder response.
#[get("/finale/finale_start")]
pub async fn finale_start(_user_auth: AuthGuard) -> ArcResult<Json<HashMap<String, Value>>> {
    let mut response = HashMap::new();
    response.insert("success".to_string(), Value::Bool(true));
    response.insert("value".to_string(), Value::Object(serde_json::Map::new()));

    Ok(Json(response))
}
