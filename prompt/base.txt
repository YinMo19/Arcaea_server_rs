我正在打算用 rust 重写一个 python flask 实现的后端服务。我已经简单构想了整个项目的模样，我想让你阅读 python 源代码并帮我实现。一些结构上和基础内容：

数据库方面，我打算使用 mariadb，并使用 sqlx 操作。我希望你尽量使用 query! query_as! query_scale!宏，在编译期判断 sql 正确性，并且尽可能的使用 struct 直接映射到 sql 内部的表格，而非使用 row.get 获取，因此我可以给你一个 mysql://arcaea:yinmo19sprivite@localhost:3306/arcaea_core 这样的实际可用的 mariadb 实例供参考。 另外数据库结构我已经设计好了（从 python 版本相似的结构） 我会在下面列出整个数据库迁移作为整个数据库结构, 你需要根据这个数据库结构来写 sql。另外我已经完成了迁移。

python 版本在 py_version文件夹内，这个文件夹目前处于 gitignore 状态，你使用 function call 可能无法 grep 其中内容，想要查找文件或者查找内容直接使用命令行的 grep 和 find。你必须阅读 python 的代码 ，每一行和每一个实现都完全摸清了才能开始写 rust 版本的内容，由于提前约定好了 api，因此你必须保证 python 版本的 api 和 rust 版本的 api 完全一致，不能有任何区别，否则将会引起错误。

关于 python 版本的结构，路由相关的文件在 server 文件夹下面，而核心逻辑在 core 下面。你必须要保证我的路由和 server 下面定义的路由完全一致，而我的 service 逻辑和 python 版本的 core 逻辑一致。

一些结构上的想法（已经初步实现，你需要保证与之前实现的一致性）：我希望你去阅读 python 版本的错误，并根据他的错误处理方式来专门给我产生处理错误的文件。我期望你使用 thiserror 来处理所有错误。所有 api 最后都返回 result T, ArcError 这里的 错误是 thiserror 的一个 enum。  除此之外，我希望我的整个项目是一个 service 和 route 分离的结构。我希望这样，一个 service 文件夹和一个 route 文件夹，以及一个对应的 model 文件，分别处理主要逻辑，路由以及数据库对应的结构。python 的代码是正确的实现，你只需要根据 python 的逻辑完成 rust 的重写即可。代码风格上保持和现有代码一致，我的一个要求是尽量把所有 struct 全部放在对应的 model 内， service 单文件不超过 1000 行。常量模块在 lib.rs 和 config.rs 里面均有定义，如需可查看。如果你需要获取客户端 ip，我已经完成了一个 ctx 可以让你作为 guard 直接使用，获取客户 ip 和其他信息，具体可以在 context.rs 查看。

最后我的要求是，你要假设你是 linus，对代码的要求是简洁和可用性高于一切。 所有对函数的详细文档都直接写在 rust 函数的上方的函数文档内，对功能进行详细描述即可。不要另外开 markdown 来写文档，毫无必要，任何进展直接告诉我即可。
 在写完之后记得 cargo check 保证能够过编译。如果你确认能过通过编译，那么可以进行测试，如果你需要测试，直接用最简单的 curl -X POST "http://localhost:8090/user" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "name=ciallo" \
     -d "password=0d000721" \
     -d "email=arcaea@yinmo19.top" \
     -d "device_id=0ed5525d2a77e201" 这样的 curl 直接使用命令行测试，如果你需要 token，curl -X POST "http://localhost:8090/auth/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -H "Authorization: Basic Y2lhbGxvOjBkMDAwNzIx" \
     -d "grant_type=client_credentials" 可以获取到你需要的 token。

我已经在后台使用 cargo watch 跑起来一个最新的案例，保证能够编译就自然是最新的，你可以放心的直接 curl 来看看结果如何，不要自己运行实例。不要新开任何的 test 文件来写一些毫无用处的测试。如果你认为你的 curl 足够简单，就像我给的案例这样，你可以放在 scripts 下面，每个 curl 一个sh文件，上面的案例在 register.sh 内。不要写任何的echo... 一个 sh 文件不超过五个 curl命令，不超过 20 行。

python 版本无论多复杂都不允许你做任何简化，除非你能保证最后逻辑结果完全一致，否则保持一模一样的实现，不要自作聪明。对于暂时无法完成的模块允许使用 todo 保留，但是尽量完成。

数据库迁移文件如下
-- MariaDB migration from SQLite
CREATE TABLE IF NOT EXISTS config (id VARCHAR(255) PRIMARY KEY, value TEXT);

CREATE TABLE user (
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(255) UNIQUE,
  password TEXT,
  join_date BIGINT,
  user_code VARCHAR(255),
  rating_ptt INT,
  character_id INT,
  is_skill_sealed TINYINT,
  is_char_uncapped TINYINT,
  is_char_uncapped_override TINYINT,
  is_hide_rating TINYINT,
  song_id TEXT,
  difficulty INT,
  score INT,
  shiny_perfect_count INT,
  perfect_count INT,
  near_count INT,
  miss_count INT,
  health INT,
  modifier INT,
  time_played BIGINT,
  clear_type INT,
  rating DOUBLE,
  favorite_character INT,
  max_stamina_notification_enabled TINYINT,
  current_map TEXT,
  ticket INT,
  prog_boost INT,
  email VARCHAR(255),
  world_rank_score INT,
  ban_flag TEXT,
  next_fragstam_ts BIGINT,
  max_stamina_ts BIGINT,
  stamina INT,
  world_mode_locked_end_ts BIGINT,
  beyond_boost_gauge DOUBLE DEFAULT 0,
  kanae_stored_prog DOUBLE DEFAULT 0,
  mp_notification_enabled TINYINT DEFAULT 1,
  highest_rating_ptt INT DEFAULT 0,
  insight_state INT DEFAULT 4
);

CREATE TABLE IF NOT EXISTS login (
  access_token TEXT,
  user_id INT,
  login_time BIGINT,
  login_ip TEXT,
  login_device TEXT,
  PRIMARY KEY (access_token (255), user_id)
);

CREATE TABLE IF NOT EXISTS friend (
  user_id_me INT,
  user_id_other INT,
  PRIMARY KEY (user_id_me, user_id_other)
);

CREATE TABLE IF NOT EXISTS best_score (
  user_id INT,
  song_id VARCHAR(255),
  difficulty INT,
  score INT,
  shiny_perfect_count INT,
  perfect_count INT,
  near_count INT,
  miss_count INT,
  health INT,
  modifier INT,
  time_played BIGINT,
  best_clear_type INT,
  clear_type INT,
  rating DOUBLE DEFAULT 0,
  score_v2 DOUBLE DEFAULT 0,
  PRIMARY KEY (user_id, song_id, difficulty)
);

CREATE TABLE IF NOT EXISTS `character` (
  character_id INT PRIMARY KEY,
  name TEXT,
  max_level INT,
  frag1 DOUBLE,
  prog1 DOUBLE,
  overdrive1 DOUBLE,
  frag20 DOUBLE,
  prog20 DOUBLE,
  overdrive20 DOUBLE,
  frag30 DOUBLE,
  prog30 DOUBLE,
  overdrive30 DOUBLE,
  skill_id TEXT,
  skill_unlock_level INT,
  skill_requires_uncap TINYINT,
  skill_id_uncap TEXT,
  char_type INT,
  is_uncapped TINYINT
);

CREATE TABLE IF NOT EXISTS user_char (
  user_id INT NOT NULL,
  character_id INT NOT NULL,
  level INT,
  exp DOUBLE,
  is_uncapped TINYINT,
  is_uncapped_override TINYINT,
  skill_flag INT,
  FOREIGN KEY (user_id) REFERENCES user (user_id),
  FOREIGN KEY (character_id) REFERENCES `character` (character_id)
);

CREATE TABLE IF NOT EXISTS user_char_full (
  user_id INT NOT NULL,
  character_id INT NOT NULL,
  level INT,
  exp DOUBLE,
  is_uncapped TINYINT,
  is_uncapped_override TINYINT,
  skill_flag INT,
  FOREIGN KEY (user_id) REFERENCES user (user_id),
  FOREIGN KEY (character_id) REFERENCES `character` (character_id)
);

CREATE TABLE IF NOT EXISTS char_item (
  character_id INT,
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (character_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS recent30 (
  user_id INT,
  r_index INT,
  time_played BIGINT,
  song_id VARCHAR(255),
  difficulty INT,
  score INT DEFAULT 0,
  shiny_perfect_count INT DEFAULT 0,
  perfect_count INT DEFAULT 0,
  near_count INT DEFAULT 0,
  miss_count INT DEFAULT 0,
  health INT DEFAULT 0,
  modifier INT DEFAULT 0,
  clear_type INT DEFAULT 0,
  rating DOUBLE DEFAULT 0,
  PRIMARY KEY (user_id, r_index)
);

CREATE TABLE IF NOT EXISTS user_world (
  user_id INT,
  map_id VARCHAR(255),
  curr_position INT,
  curr_capture DOUBLE,
  is_locked TINYINT,
  PRIMARY KEY (user_id, map_id)
);

CREATE TABLE IF NOT EXISTS songplay_token (
  token VARCHAR(255) PRIMARY KEY,
  user_id INT,
  song_id VARCHAR(255),
  difficulty INT,
  course_id VARCHAR(255),
  course_state INT,
  course_score INT,
  course_clear_type INT,
  stamina_multiply INT,
  fragment_multiply INT,
  prog_boost_multiply INT,
  beyond_boost_gauge_usage INT,
  skill_cytusii_flag TEXT,
  skill_chinatsu_flag TEXT,
  invasion_flag INT
);

CREATE TABLE IF NOT EXISTS item (
  item_id VARCHAR(255),
  type VARCHAR(255),
  is_available TINYINT,
  PRIMARY KEY (item_id, type)
);

CREATE TABLE IF NOT EXISTS user_item (
  user_id INT,
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (user_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS purchase (
  purchase_name VARCHAR(255) PRIMARY KEY,
  price INT,
  orig_price INT,
  discount_from BIGINT,
  discount_to BIGINT,
  discount_reason TEXT
);

CREATE TABLE IF NOT EXISTS purchase_item (
  purchase_name VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (purchase_name, item_id, type)
);

CREATE TABLE IF NOT EXISTS user_save (
  user_id INT PRIMARY KEY,
  scores_data TEXT,
  clearlamps_data TEXT,
  clearedsongs_data TEXT,
  unlocklist_data TEXT,
  installid_data TEXT,
  devicemodelname_data TEXT,
  story_data TEXT,
  createdAt BIGINT,
  finalestate_data TEXT
);

CREATE TABLE IF NOT EXISTS present (
  present_id VARCHAR(255) PRIMARY KEY,
  expire_ts BIGINT,
  description TEXT
);

CREATE TABLE IF NOT EXISTS user_present (
  user_id INT,
  present_id VARCHAR(255),
  PRIMARY KEY (user_id, present_id)
);

CREATE TABLE IF NOT EXISTS present_item (
  present_id VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (present_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS chart (
  song_id VARCHAR(255) PRIMARY KEY,
  name TEXT,
  rating_pst INT DEFAULT -1,
  rating_prs INT DEFAULT -1,
  rating_ftr INT DEFAULT -1,
  rating_byn INT DEFAULT -1,
  rating_etr INT DEFAULT -1
);

CREATE TABLE IF NOT EXISTS redeem (code VARCHAR(255) PRIMARY KEY, type INT);

CREATE TABLE IF NOT EXISTS user_redeem (
  user_id INT,
  code VARCHAR(255),
  PRIMARY KEY (user_id, code)
);

CREATE TABLE IF NOT EXISTS redeem_item (
  code VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (code, item_id, type)
);

CREATE TABLE IF NOT EXISTS role (role_id VARCHAR(255) PRIMARY KEY, caption TEXT);

CREATE TABLE IF NOT EXISTS user_role (
  user_id INT,
  role_id VARCHAR(255),
  PRIMARY KEY (user_id, role_id)
);

CREATE TABLE IF NOT EXISTS power(power_id VARCHAR(255) PRIMARY KEY, caption TEXT);

CREATE TABLE IF NOT EXISTS role_power (
  role_id VARCHAR(255),
  power_id VARCHAR(255),
  PRIMARY KEY (role_id, power_id)
);

CREATE TABLE IF NOT EXISTS api_login (
  user_id INT,
  token VARCHAR(255),
  login_time BIGINT,
  login_ip TEXT,
  PRIMARY KEY (user_id, token)
);

CREATE TABLE IF NOT EXISTS course (
  course_id VARCHAR(255) PRIMARY KEY,
  course_name TEXT,
  dan_name TEXT,
  style INT,
  gauge_requirement TEXT,
  flag_as_hidden_when_requirements_not_met TINYINT,
  can_start TINYINT
);

CREATE TABLE IF NOT EXISTS user_course (
  user_id INT,
  course_id VARCHAR(255),
  high_score INT,
  best_clear_type INT,
  PRIMARY KEY (user_id, course_id)
);

CREATE TABLE IF NOT EXISTS course_chart (
  course_id VARCHAR(255),
  song_id VARCHAR(255),
  difficulty INT,
  flag_as_hidden TINYINT,
  song_index INT,
  PRIMARY KEY (course_id, song_index)
);

CREATE TABLE IF NOT EXISTS course_requirement (
  course_id VARCHAR(255),
  required_id VARCHAR(255),
  PRIMARY KEY (course_id, required_id)
);

CREATE TABLE IF NOT EXISTS course_item (
  course_id VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (course_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS user_mission (
  user_id INT,
  mission_id VARCHAR(255),
  status INT,
  PRIMARY KEY (user_id, mission_id)
);

CREATE TABLE IF NOT EXISTS user_kvdata (
  user_id INT,
  class VARCHAR(255),
  `key` VARCHAR(255),
  idx INT,
  value TEXT,
  PRIMARY KEY (user_id, class, `key`, idx)
);

CREATE INDEX IF NOT EXISTS best_score_1 ON best_score (song_id, difficulty);

CREATE TABLE IF NOT EXISTS user_custom_course (
  user_id INT,
  custom_course TEXT,
  PRIMARY KEY (user_id)
);

CREATE TABLE IF NOT EXISTS download_token (
  user_id INT,
  song_id VARCHAR(255),
  file_name VARCHAR(255),
  token VARCHAR(255),
  time BIGINT,
  PRIMARY KEY (user_id, song_id, file_name)
);


-- Add notification and bundle download tables
CREATE TABLE IF NOT EXISTS notification (
  user_id INT,
  id INT,
  type VARCHAR(255),
  content TEXT,
  sender_user_id INT,
  sender_name VARCHAR(255),
  timestamp BIGINT,
  PRIMARY KEY (user_id, id)
);

CREATE TABLE IF NOT EXISTS bundle_download_token (
  token VARCHAR(255) PRIMARY KEY,
  file_path TEXT,
  time BIGINT,
  device_id VARCHAR(255)
);
这是所有数据库接口，你无需再阅读现有的数据库迁移。

下面是我需要你帮我实现的目标：

我基于 python 的 item 模块实现了 rust 版本的 item 模块。这个模块并不提供 route，而是给购买和用户提供服务的一些接口。我希望你能帮我完善我的 user 和 purchase 以及 aggregate 模块（这个模块付属于 others 路由，在 services/下面）下面是 item.py的全部内容

from .config_manager import Config
from .error import (DataExist, InputError, ItemNotEnough, ItemUnavailable,
                    NoData)


class Item:
    item_type = None

    def __init__(self, c=None) -> None:
        self.item_id = None
        self.__amount = None
        self.is_available = None
        self.c = c

    def __eq__(self, other: 'Item') -> bool:
        return self.item_id == other.item_id and self.item_type == other.item_type

    @property
    def amount(self):
        return self.__amount

    @amount.setter
    def amount(self, value: int):
        self.__amount = int(value)

    def to_dict(self, has_is_available: bool = False, has_amount: bool = True) -> dict:
        r = {
            'id': self.item_id,
            'type': self.item_type
        }
        if has_amount:
            r['amount'] = self.amount
        if has_is_available:
            r['is_available'] = self.is_available
        return r

    def user_claim_item(self, user):
        # parameter: user - User类或子类的实例
        pass

    def select_exists(self):
        self.c.execute('''select exists(select * from item where item_id=? and type=?)''',
                       (self.item_id, self.item_type))
        return bool(self.c.fetchone()[0])

    def insert(self, ignore: bool = False):
        sql = '''insert into item values(?,?,?)''' if not ignore else '''insert or ignore into item values(?,?,?)'''
        self.c.execute(sql, (self.item_id, self.item_type, self.is_available))

    def delete(self):
        self.c.execute('''delete from item where item_id=? and type=?''',
                       (self.item_id, self.item_type))

    def update(self):
        self.c.execute('''update item set is_available=? where item_id=? and type=?''',
                       (self.is_available, self.item_id, self.item_type))

    def select(self):
        self.c.execute('''select is_available from item where item_id=? and type=?''',
                       (self.item_id, self.item_type))
        x = self.c.fetchone()
        if not x:
            raise NoData(
                f'No such item `{self.item_type}`: `{self.item_id}`', api_error_code=-121)
        self.is_available = x[0]


class UserItem(Item):

    def __init__(self, c=None) -> None:
        super().__init__()
        self.c = c
        self.user = None

    def select_user_item(self, user=None):
        '''
            查询用户item

            parameter: `user` - `User`类或子类的实例
        '''
        if user is not None:
            self.user = user
        self.c.execute('''select amount from user_item where user_id=? and item_id=? and type=?''',
                       (self.user.user_id, self.item_id, self.item_type))
        x = self.c.fetchone()
        if x:
            self.amount = x[0] if x[0] is not None else 1
        else:
            self.amount = 0


class NormalItem(UserItem):
    def __init__(self, c=None) -> None:
        super().__init__()
        self.c = c

    def user_claim_item(self, user):
        self.user = user
        if not self.is_available:
            self.c.execute(
                '''select is_available from item where item_id=? and type=?''', (self.item_id, self.item_type))
            x = self.c.fetchone()
            if x:
                if x[0] == 0:
                    self.is_available = False
                    raise ItemUnavailable('The item is unavailable.')
                self.is_available = True
            else:
                raise NoData('No item data.')

        self.c.execute('''select exists(select * from user_item where user_id=? and item_id=? and type=?)''',
                       (self.user.user_id, self.item_id, self.item_type))
        if self.c.fetchone() == (0,):
            self.c.execute('''insert into user_item values(:a,:b,:c,1)''',
                           {'a': self.user.user_id, 'b': self.item_id, 'c': self.item_type})


class PositiveItem(UserItem):
    def __init__(self, c=None) -> None:
        super().__init__()
        self.c = c

    def user_claim_item(self, user):
        '''添加或使用用户item，注意是+amount'''
        self.user = user
        self.c.execute('''select amount from user_item where user_id=? and item_id=? and type=?''',
                       (self.user.user_id, self.item_id, self.item_type))
        x = self.c.fetchone()
        if x:
            if x[0] + self.amount < 0:  # 数量不足
                raise ItemNotEnough(
                    'The user does not have enough `%s`.' % self.item_id)
            self.c.execute('''update user_item set amount=? where user_id=? and item_id=? and type=?''',
                           (x[0]+self.amount, self.user.user_id, self.item_id, self.item_type))
        else:
            if self.amount < 0:  # 添加数量错误
                raise InputError(
                    'The amount of `%s` is wrong.' % self.item_id)
            self.c.execute('''insert into user_item values(?,?,?,?)''',
                           (self.user.user_id, self.item_id, self.item_type, self.amount))


class ItemCore(PositiveItem):
    item_type = 'core'

    def __init__(self, c=None, core_type: str = '', amount: int = 0) -> None:
        super().__init__(c)
        self.is_available = True
        self.item_id = core_type
        self.amount = amount

    def __str__(self) -> str:
        return self.item_id + '_' + str(self.amount)

    def to_dict(self, has_is_available: bool = False, has_amount: bool = True, character_format: bool = False) -> dict:
        if character_format:
            # 搭档的core是特殊格式的
            return {'core_type': self.item_id, 'amount': self.amount}
        return super().to_dict(has_is_available=has_is_available, has_amount=has_amount)

    def user_claim_item(self, user, reverse: bool = False) -> None:
        # 骚操作，将amount变为负数后使用再变回来
        if reverse:
            self.amount = -self.amount
        super().user_claim_item(user)
        if reverse:
            self.amount = -self.amount


class ItemCharacter(UserItem):
    item_type = 'character'

    def __init__(self, c) -> None:
        super().__init__()
        self.c = c
        self.is_available = True

    def set_id(self, character_id: str) -> None:
        # 将name: str转为character_id: int存到item_id里
        if character_id.isdigit():
            self.item_id = int(character_id)
        else:
            self.c.execute(
                '''select character_id from character where name=?''', (character_id,))
            x = self.c.fetchone()
            if x:
                self.item_id = x[0]
            else:
                raise NoData('No character `%s`.' % character_id)

    def user_claim_item(self, user):
        if not isinstance(self.item_id, int):
            self.set_id(self.item_id)

        self.c.execute(
            '''select exists(select * from user_char where user_id=? and character_id=?)''', (user.user_id, self.item_id))
        if self.c.fetchone() == (0,):
            self.c.execute(
                '''insert into user_char values(?,?,1,0,0,0,0)''', (user.user_id, self.item_id))


class Memory(UserItem):
    item_type = 'memory'

    def __init__(self, c) -> None:
        super().__init__()
        self.c = c
        self.is_available = True

    def user_claim_item(self, user):
        self.c.execute(
            '''select ticket from user where user_id=?''', (user.user_id,))
        x = self.c.fetchone()
        if x is not None:
            self.c.execute('''update user set ticket=? where user_id=?''',
                           (x[0]+self.amount, user.user_id))
        else:
            raise NoData('The ticket of the user is null.')


class Fragment(UserItem):
    item_type = 'fragment'

    def __init__(self, c=None, amount=0) -> None:
        super().__init__()
        self.c = c
        self.is_available = True
        self.item_id = self.item_type
        self.amount = amount

    def user_claim_item(self, user):
        pass

    def __str__(self) -> str:
        return 'fragment' + str(self.amount)


class Anni5tix(PositiveItem):
    item_type = 'anni5tix'

    def __init__(self, c) -> None:
        super().__init__(c)
        self.is_available = True
        self.item_id = self.item_type
        self.amount = 1


class PickTicket(PositiveItem):
    item_type = 'pick_ticket'

    def __init__(self, c=None) -> None:
        super().__init__(c)
        self.is_available = True
        self.item_id = self.item_type
        self.amount = 1


class WorldSong(NormalItem):
    item_type = 'world_song'

    def __init__(self, c=None) -> None:
        super().__init__(c)
        self.is_available = True


class WorldUnlock(NormalItem):
    item_type = 'world_unlock'

    def __init__(self, c) -> None:
        super().__init__(c)
        self.is_available = True


class CourseBanner(NormalItem):
    item_type = 'course_banner'

    def __init__(self, c) -> None:
        super().__init__(c)
        self.is_available = True

    def __str__(self) -> str:
        return str(self.item_id)


class Single(NormalItem):
    item_type = 'single'


class Pack(NormalItem):
    item_type = 'pack'


class ProgBoost(UserItem):
    item_type = 'prog_boost_300'

    def __init__(self, c) -> None:
        super().__init__(c)

    def user_claim_item(self, user):
        '''
            世界模式prog_boost

            parameters: `user` - `UserOnline`类或子类的实例
        '''
        user.update_user_one_column('prog_boost', 300)


class Stamina6(UserItem):
    item_type = 'stamina6'

    def __init__(self, c=None) -> None:
        super().__init__(c)
        self.item_id = 'stamina6'
        self.amount = 1

    def user_claim_item(self, user):
        '''
            世界模式记忆源点或残片买体力+6
            顺手清一下世界模式过载状态
        '''
        user.select_user_about_stamina()
        user.stamina.stamina += 6
        user.stamina.update()
        user.update_user_one_column('world_mode_locked_end_ts', -1)


class ItemStamina(UserItem):
    item_type = 'stamina'

    def __init__(self, c=None, amount=1) -> None:
        super().__init__(c)
        self.item_id = 'stamina'
        self.amount = amount

    def user_claim_item(self, user):
        '''
            新手任务奖励体力
        '''
        user.select_user_about_stamina()
        user.stamina.stamina += self.amount
        user.stamina.update()


class ItemFactory:
    def __init__(self, c=None) -> None:
        self.c = c

    def get_item(self, item_type: str):
        '''
            根据item_type实例化对应的item类
            return: Item类或子类的实例
        '''
        if item_type == 'core':
            return ItemCore(self.c)
        elif item_type == 'character':
            return ItemCharacter(self.c)
        elif item_type == 'memory':
            return Memory(self.c)
        elif item_type == 'anni5tix':
            return Anni5tix(self.c)
        elif item_type == 'pick_ticket':
            return PickTicket(self.c)
        elif item_type == 'world_song':
            return WorldSong(self.c)
        elif item_type == 'world_unlock':
            return WorldUnlock(self.c)
        elif item_type == 'single':
            return Single(self.c)
        elif item_type == 'pack':
            return Pack(self.c)
        elif item_type == 'fragment':
            return Fragment(self.c)
        elif item_type == 'prog_boost_300':
            return ProgBoost(self.c)
        elif item_type == 'stamina6':
            return Stamina6(self.c)
        elif item_type == 'course_banner':
            return CourseBanner(self.c)
        else:
            raise InputError(
                f'The item type `{item_type}` is invalid.', api_error_code=-120)

    @classmethod
    def from_dict(cls, d: dict, c=None):
        '''注意这里没有处理character_id的转化，是为了世界模式的map服务的'''
        if 'item_type' in d:
            item_type = d['item_type']
        elif 'type' in d:
            item_type = d['type']
        else:
            raise InputError('The dict of item is wrong.')
        i = cls().get_item(item_type)
        if c is not None:
            i.c = c
        if 'item_id' in d:
            i.item_id = d['item_id']
        elif 'id' in d:
            i.item_id = d['id']
        else:
            i.item_id = item_type
        i.amount = d.get('amount', 1)
        i.is_available = d.get('is_available', True)
        return i

    @classmethod
    def from_str(cls, s: str, c=None):
        if s.startswith('fragment'):
            item_type = 'fragment'
            item_id = 'fragment'
            amount = int(s[8:])
        elif s.startswith('core'):
            item_type = 'core'
            x = s.split('_')
            item_id = x[0] + '_' + x[1]
            amount = int(x[-1])
        elif s.startswith('course_banner'):
            item_type = 'course_banner'
            item_id = s
            amount = 1
        else:
            raise InputError('The string of item is wrong.')
        i = cls().get_item(item_type)
        if c is not None:
            i.c = c
        i.item_id = item_id
        i.amount = amount
        i.is_available = True
        return i


class UserItemList:
    '''
        用户的item列表
        注意只能查在user_item里面的，character不行
        properties: `user` - `User`类或子类的实例
    '''

    def __init__(self, c=None, user=None):
        self.c = c
        self.user = user

        self.items: list = []

    def select_from_type(self, item_type: str) -> 'UserItemList':
        '''
            根据item_type搜索用户的item
        '''
        if Config.WORLD_SONG_FULL_UNLOCK and item_type == 'world_song' or Config.WORLD_SCENERY_FULL_UNLOCK and item_type == 'world_unlock':
            self.c.execute(
                '''select item_id from item where type=?''', (item_type,))
        else:
            self.c.execute('''select item_id, amount from user_item where type = :a and user_id = :b''', {
                'a': item_type, 'b': self.user.user_id})
        x = self.c.fetchall()
        if not x:
            return self

        self.items: list = []
        for i in x:
            if len(i) > 1:
                amount = i[1] if i[1] is not None else 1
            else:
                amount = 1
            self.items.append(ItemFactory.from_dict(
                {'item_id': i[0], 'amount': amount, 'item_type': item_type}, self.c))
        return self


class CollectionItemMixin:
    '''
       批量修改一些集合中的items
    '''
    collection_item_const = {
        'name': 'collection',
        'table_name': 'collection_item',
        'table_primary_key': 'collection_id',
        'id_name': 'collection_id',
        'items_name': 'items'
    }

    def add_items(self, items: 'list[Item]') -> None:
        collection_id: 'str' = getattr(
            self, self.collection_item_const['id_name'])
        collection_items: 'list[Item]' = getattr(
            self, self.collection_item_const['items_name'])

        for i in items:
            if not i.select_exists():
                raise NoData(
                    f'No such item `{i.item_type}`: `{i.item_id}`', api_error_code=-121)
            if i in collection_items:
                raise DataExist(
                    f'Item `{i.item_type}`: `{i.item_id}` already exists in {self.collection_item_const["name"]} `{collection_id}`', api_error_code=-123)
        self.c.executemany(f'''insert into {self.collection_item_const["table_name"]} values (?, ?, ?, ?)''', [
                           (collection_id, i.item_id, i.item_type, i.amount) for i in items])
        collection_items.extend(items)

    def remove_items(self, items: 'list[Item]') -> None:
        collection_id: 'str' = getattr(
            self, self.collection_item_const['id_name'])
        collection_items: 'list[Item]' = getattr(
            self, self.collection_item_const['items_name'])

        for i in items:
            if i not in collection_items:
                raise NoData(
                    f'No such item `{i.item_type}`: `{i.item_id}` in {self.collection_item_const["name"]} `{collection_id}`', api_error_code=-124)
        self.c.executemany(f'''delete from {self.collection_item_const["table_name"]} where {self.collection_item_const["table_primary_key"]}=? and item_id=? and type=?''', [
                           (collection_id, i.item_id, i.item_type) for i in items])
        for i in items:
            collection_items.remove(i)

    def update_items(self, items: 'list[Item]') -> None:
        collection_id: 'str' = getattr(
            self, self.collection_item_const['id_name'])
        collection_items: 'list[Item]' = getattr(
            self, self.collection_item_const['items_name'])

        for i in items:
            if i not in collection_items:
                raise NoData(
                    f'No such item `{i.item_type}`: `{i.item_id}` in {self.collection_item_const["name"]} `{collection_id}`', api_error_code=-124)
        self.c.executemany(f'''update {self.collection_item_const["table_name"]} set amount=? where {self.collection_item_const["table_primary_key"]}=? and item_id=? and type=?''', [
                           (i.amount, collection_id, i.item_id, i.item_type) for i in items])
        for i in items:
            collection_items[collection_items.index(i)].amount = i.amount
你需要*完整*阅读 user.py和我提到的 python 模块，然后根据调用关系看看我的代码有什么缺陷（例如本应该直接使用 item 模块的服务却在 user 服务中自己实现了一个简陋版本，那么删掉捡漏实现，直接调用 item 完整实现，又或者 user 模块有什么未实现功能，直接实现）。
