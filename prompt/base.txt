我正在打算用 rust 重写一个 python flask 实现的后端服务。我已经简单构想了整个项目的模样，我想让你阅读 python 源代码并帮我实现。一些结构上和基础内容：

数据库方面，我打算使用 mariadb，并使用 sqlx 操作。我希望你尽量使用 query! query_as! query_scale!宏，在编译期判断 sql 正确性，并且尽可能的使用 struct 直接映射到 sql 内部的表格，而非使用 row.get 获取，因此我可以给你一个 mysql://arcaea:yinmo19sprivite@localhost:3306/arcaea_core 这样的实际可用的 mariadb 实例供参考。 另外数据库结构我已经设计好了（从 python 版本相似的结构） 我会在下面列出整个数据库迁移作为整个数据库结构, 你需要根据这个数据库结构来写 sql。另外我已经完成了迁移。

python 版本在 py_version文件夹内，这个文件夹目前处于 gitignore 状态，你使用 function call 可能无法 grep 其中内容，想要查找文件或者查找内容直接使用命令行的 grep 和 find。你必须阅读 python 的代码 ，每一行和每一个实现都完全摸清了才能开始写 rust 版本的内容，由于提前约定好了 api，因此你必须保证 python 版本的 api 和 rust 版本的 api 完全一致，不能有任何区别，否则将会引起错误。

关于 python 版本的结构，路由相关的文件在 server 文件夹下面，而核心逻辑在 core 下面。你必须要保证我的路由和 server 下面定义的路由完全一致，而我的 service 逻辑和 python 版本的 core 逻辑一致。

一些结构上的想法（已经初步实现，你需要保证与之前实现的一致性）：我希望你去阅读 python 版本的错误，并根据他的错误处理方式来专门给我产生处理错误的文件。我期望你使用 thiserror 来处理所有错误。所有 api 最后都返回 result T, ArcError 这里的 错误是 thiserror 的一个 enum。  除此之外，我希望我的整个项目是一个 service 和 route 分离的结构。我希望这样，一个 service 文件夹和一个 route 文件夹，以及一个对应的 model 文件，分别处理主要逻辑，路由以及数据库对应的结构。python 的代码是正确的实现，你只需要根据 python 的逻辑完成 rust 的重写即可。代码风格上保持和现有代码一致，我的一个要求是尽量把所有 struct 全部放在对应的 model 内， service 单文件不超过 1000 行。常量模块在 lib.rs 和 config.rs 里面均有定义，如需可查看。如果你需要获取客户端 ip，我已经完成了一个 ctx 可以让你作为 guard 直接使用，获取客户 ip 和其他信息，具体可以在 context.rs 查看。

最后我的要求是，你要假设你是 linus，对代码的要求是简洁和可用性高于一切。 所有对函数的详细文档都直接写在 rust 函数的上方的函数文档内，对功能进行详细描述即可。不要另外开 markdown 来写文档，毫无必要，任何进展直接告诉我即可。
 在写完之后记得 cargo check 保证能够过编译。如果你确认能过通过编译，那么可以进行测试，如果你需要测试，直接用最简单的 curl -X POST "http://localhost:8090/user" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "name=ciallo" \
     -d "password=0d000721" \
     -d "email=arcaea@yinmo19.top" \
     -d "device_id=0ed5525d2a77e201" 这样的 curl 直接使用命令行测试，如果你需要 token，curl -X POST "http://localhost:8090/auth/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -H "Authorization: Basic Y2lhbGxvOjBkMDAwNzIx" \
     -d "grant_type=client_credentials" 可以获取到你需要的 token。

我已经在后台使用 cargo watch 跑起来一个最新的案例，保证能够编译就自然是最新的，你可以放心的直接 curl 来看看结果如何，不要自己运行实例。不要新开任何的 test 文件来写一些毫无用处的测试。如果你认为你的 curl 足够简单，就像我给的案例这样，你可以放在 scripts 下面，每个 curl 一个sh文件，上面的案例在 register.sh 内。不要写任何的echo... 一个 sh 文件不超过五个 curl命令，不超过 20 行。

python 版本无论多复杂都不允许你做任何简化，除非你能保证最后逻辑结果完全一致，否则保持一模一样的实现，不要自作聪明。对于暂时无法完成的模块允许使用 todo 保留，但是尽量完成。

数据库迁移文件如下
-- MariaDB migration from SQLite
CREATE TABLE IF NOT EXISTS config (id VARCHAR(255) PRIMARY KEY, value TEXT);

CREATE TABLE user (
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(255) UNIQUE,
  password TEXT,
  join_date BIGINT,
  user_code VARCHAR(255),
  rating_ptt INT,
  character_id INT,
  is_skill_sealed TINYINT,
  is_char_uncapped TINYINT,
  is_char_uncapped_override TINYINT,
  is_hide_rating TINYINT,
  song_id TEXT,
  difficulty INT,
  score INT,
  shiny_perfect_count INT,
  perfect_count INT,
  near_count INT,
  miss_count INT,
  health INT,
  modifier INT,
  time_played BIGINT,
  clear_type INT,
  rating DOUBLE,
  favorite_character INT,
  max_stamina_notification_enabled TINYINT,
  current_map TEXT,
  ticket INT,
  prog_boost INT,
  email VARCHAR(255),
  world_rank_score INT,
  ban_flag TEXT,
  next_fragstam_ts BIGINT,
  max_stamina_ts BIGINT,
  stamina INT,
  world_mode_locked_end_ts BIGINT,
  beyond_boost_gauge DOUBLE DEFAULT 0,
  kanae_stored_prog DOUBLE DEFAULT 0,
  mp_notification_enabled TINYINT DEFAULT 1,
  highest_rating_ptt INT DEFAULT 0,
  insight_state INT DEFAULT 4
);

CREATE TABLE IF NOT EXISTS login (
  access_token TEXT,
  user_id INT,
  login_time BIGINT,
  login_ip TEXT,
  login_device TEXT,
  PRIMARY KEY (access_token (255), user_id)
);

CREATE TABLE IF NOT EXISTS friend (
  user_id_me INT,
  user_id_other INT,
  PRIMARY KEY (user_id_me, user_id_other)
);

CREATE TABLE IF NOT EXISTS best_score (
  user_id INT,
  song_id VARCHAR(255),
  difficulty INT,
  score INT,
  shiny_perfect_count INT,
  perfect_count INT,
  near_count INT,
  miss_count INT,
  health INT,
  modifier INT,
  time_played BIGINT,
  best_clear_type INT,
  clear_type INT,
  rating DOUBLE DEFAULT 0,
  score_v2 DOUBLE DEFAULT 0,
  PRIMARY KEY (user_id, song_id, difficulty)
);

CREATE TABLE IF NOT EXISTS `character` (
  character_id INT PRIMARY KEY,
  name TEXT,
  max_level INT,
  frag1 DOUBLE,
  prog1 DOUBLE,
  overdrive1 DOUBLE,
  frag20 DOUBLE,
  prog20 DOUBLE,
  overdrive20 DOUBLE,
  frag30 DOUBLE,
  prog30 DOUBLE,
  overdrive30 DOUBLE,
  skill_id TEXT,
  skill_unlock_level INT,
  skill_requires_uncap TINYINT,
  skill_id_uncap TEXT,
  char_type INT,
  is_uncapped TINYINT
);

CREATE TABLE IF NOT EXISTS user_char (
  user_id INT NOT NULL,
  character_id INT NOT NULL,
  level INT,
  exp DOUBLE,
  is_uncapped TINYINT,
  is_uncapped_override TINYINT,
  skill_flag INT,
  FOREIGN KEY (user_id) REFERENCES user (user_id),
  FOREIGN KEY (character_id) REFERENCES `character` (character_id)
);

CREATE TABLE IF NOT EXISTS user_char_full (
  user_id INT NOT NULL,
  character_id INT NOT NULL,
  level INT,
  exp DOUBLE,
  is_uncapped TINYINT,
  is_uncapped_override TINYINT,
  skill_flag INT,
  FOREIGN KEY (user_id) REFERENCES user (user_id),
  FOREIGN KEY (character_id) REFERENCES `character` (character_id)
);

CREATE TABLE IF NOT EXISTS char_item (
  character_id INT,
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (character_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS recent30 (
  user_id INT,
  r_index INT,
  time_played BIGINT,
  song_id VARCHAR(255),
  difficulty INT,
  score INT DEFAULT 0,
  shiny_perfect_count INT DEFAULT 0,
  perfect_count INT DEFAULT 0,
  near_count INT DEFAULT 0,
  miss_count INT DEFAULT 0,
  health INT DEFAULT 0,
  modifier INT DEFAULT 0,
  clear_type INT DEFAULT 0,
  rating DOUBLE DEFAULT 0,
  PRIMARY KEY (user_id, r_index)
);

CREATE TABLE IF NOT EXISTS user_world (
  user_id INT,
  map_id VARCHAR(255),
  curr_position INT,
  curr_capture DOUBLE,
  is_locked TINYINT,
  PRIMARY KEY (user_id, map_id)
);

CREATE TABLE IF NOT EXISTS songplay_token (
  token VARCHAR(255) PRIMARY KEY,
  user_id INT,
  song_id VARCHAR(255),
  difficulty INT,
  course_id VARCHAR(255),
  course_state INT,
  course_score INT,
  course_clear_type INT,
  stamina_multiply INT,
  fragment_multiply INT,
  prog_boost_multiply INT,
  beyond_boost_gauge_usage INT,
  skill_cytusii_flag TEXT,
  skill_chinatsu_flag TEXT,
  invasion_flag INT
);

CREATE TABLE IF NOT EXISTS item (
  item_id VARCHAR(255),
  type VARCHAR(255),
  is_available TINYINT,
  PRIMARY KEY (item_id, type)
);

CREATE TABLE IF NOT EXISTS user_item (
  user_id INT,
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (user_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS purchase (
  purchase_name VARCHAR(255) PRIMARY KEY,
  price INT,
  orig_price INT,
  discount_from BIGINT,
  discount_to BIGINT,
  discount_reason TEXT
);

CREATE TABLE IF NOT EXISTS purchase_item (
  purchase_name VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (purchase_name, item_id, type)
);

CREATE TABLE IF NOT EXISTS user_save (
  user_id INT PRIMARY KEY,
  scores_data TEXT,
  clearlamps_data TEXT,
  clearedsongs_data TEXT,
  unlocklist_data TEXT,
  installid_data TEXT,
  devicemodelname_data TEXT,
  story_data TEXT,
  createdAt BIGINT,
  finalestate_data TEXT
);

CREATE TABLE IF NOT EXISTS present (
  present_id VARCHAR(255) PRIMARY KEY,
  expire_ts BIGINT,
  description TEXT
);

CREATE TABLE IF NOT EXISTS user_present (
  user_id INT,
  present_id VARCHAR(255),
  PRIMARY KEY (user_id, present_id)
);

CREATE TABLE IF NOT EXISTS present_item (
  present_id VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (present_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS chart (
  song_id VARCHAR(255) PRIMARY KEY,
  name TEXT,
  rating_pst INT DEFAULT -1,
  rating_prs INT DEFAULT -1,
  rating_ftr INT DEFAULT -1,
  rating_byn INT DEFAULT -1,
  rating_etr INT DEFAULT -1
);

CREATE TABLE IF NOT EXISTS redeem (code VARCHAR(255) PRIMARY KEY, type INT);

CREATE TABLE IF NOT EXISTS user_redeem (
  user_id INT,
  code VARCHAR(255),
  PRIMARY KEY (user_id, code)
);

CREATE TABLE IF NOT EXISTS redeem_item (
  code VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (code, item_id, type)
);

CREATE TABLE IF NOT EXISTS role (role_id VARCHAR(255) PRIMARY KEY, caption TEXT);

CREATE TABLE IF NOT EXISTS user_role (
  user_id INT,
  role_id VARCHAR(255),
  PRIMARY KEY (user_id, role_id)
);

CREATE TABLE IF NOT EXISTS power(power_id VARCHAR(255) PRIMARY KEY, caption TEXT);

CREATE TABLE IF NOT EXISTS role_power (
  role_id VARCHAR(255),
  power_id VARCHAR(255),
  PRIMARY KEY (role_id, power_id)
);

CREATE TABLE IF NOT EXISTS api_login (
  user_id INT,
  token VARCHAR(255),
  login_time BIGINT,
  login_ip TEXT,
  PRIMARY KEY (user_id, token)
);

CREATE TABLE IF NOT EXISTS course (
  course_id VARCHAR(255) PRIMARY KEY,
  course_name TEXT,
  dan_name TEXT,
  style INT,
  gauge_requirement TEXT,
  flag_as_hidden_when_requirements_not_met TINYINT,
  can_start TINYINT
);

CREATE TABLE IF NOT EXISTS user_course (
  user_id INT,
  course_id VARCHAR(255),
  high_score INT,
  best_clear_type INT,
  PRIMARY KEY (user_id, course_id)
);

CREATE TABLE IF NOT EXISTS course_chart (
  course_id VARCHAR(255),
  song_id VARCHAR(255),
  difficulty INT,
  flag_as_hidden TINYINT,
  song_index INT,
  PRIMARY KEY (course_id, song_index)
);

CREATE TABLE IF NOT EXISTS course_requirement (
  course_id VARCHAR(255),
  required_id VARCHAR(255),
  PRIMARY KEY (course_id, required_id)
);

CREATE TABLE IF NOT EXISTS course_item (
  course_id VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (course_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS user_mission (
  user_id INT,
  mission_id VARCHAR(255),
  status INT,
  PRIMARY KEY (user_id, mission_id)
);

CREATE TABLE IF NOT EXISTS user_kvdata (
  user_id INT,
  class VARCHAR(255),
  `key` VARCHAR(255),
  idx INT,
  value TEXT,
  PRIMARY KEY (user_id, class, `key`, idx)
);

CREATE INDEX IF NOT EXISTS best_score_1 ON best_score (song_id, difficulty);

CREATE TABLE IF NOT EXISTS user_custom_course (
  user_id INT,
  custom_course TEXT,
  PRIMARY KEY (user_id)
);

CREATE TABLE IF NOT EXISTS download_token (
  user_id INT,
  song_id VARCHAR(255),
  file_name VARCHAR(255),
  token VARCHAR(255),
  time BIGINT,
  PRIMARY KEY (user_id, song_id, file_name)
);


-- Add notification and bundle download tables
CREATE TABLE IF NOT EXISTS notification (
  user_id INT,
  id INT,
  type VARCHAR(255),
  content TEXT,
  sender_user_id INT,
  sender_name VARCHAR(255),
  timestamp BIGINT,
  PRIMARY KEY (user_id, id)
);

CREATE TABLE IF NOT EXISTS bundle_download_token (
  token VARCHAR(255) PRIMARY KEY,
  file_path TEXT,
  time BIGINT,
  device_id VARCHAR(255)
);
这是所有数据库接口，你无需再阅读现有的数据库迁移。

下面是我需要你帮我实现的目标：

目前我的 score 部分实现并不完整，我希望你完全的阅读下面的 score 模块，然后帮我实现我的 score模块。我已经实现了一个基础的部分，但是并不完整。我希望你完全的阅读之后帮我实现完整的逻辑。


import os
from functools import lru_cache
from json import load
from random import randint
from time import time

from .character import Character, UserCharacter
from .config_manager import Config
from .constant import Constant
from .error import InputError, MapLocked, NoData
from .item import ItemFactory
from .sql import UserKVTable


class MapParser:

    map_id_path: 'dict[str, str]' = {}

    world_info: 'dict[str, dict]' = {}  # 简要记录地图信息
    chapter_info: 'dict[int, list[str]]' = {}  # 章节包含的地图
    # 章节包含的地图（不包含可重复地图）
    chapter_info_without_repeatable: 'dict[int, list[str]]' = {}

    def __init__(self) -> None:
        if not self.map_id_path:
            self.parse()

    def parse(self) -> None:
        for root, dirs, files in os.walk(Constant.WORLD_MAP_FOLDER_PATH):
            for file in files:
                if not file.endswith('.json'):
                    continue

                path = os.path.join(root, file)
                map_id = file[:-5]
                self.map_id_path[map_id] = path

                map_data = self.get_world_info(map_id)
                chapter = map_data.get('chapter', None)
                if chapter is None:
                    continue
                self.chapter_info.setdefault(chapter, []).append(map_id)
                is_repeatable = map_data.get('is_repeatable', False)
                if not is_repeatable:
                    self.chapter_info_without_repeatable.setdefault(
                        chapter, []).append(map_id)
                self.world_info[map_id] = {
                    'chapter': chapter,
                    'is_repeatable': is_repeatable,
                    'is_beyond': map_data.get('is_beyond', False),
                    'is_legacy': map_data.get('is_legacy', False),
                    'step_count': len(map_data.get('steps', [])),
                }

    def re_init(self) -> None:
        self.map_id_path.clear()
        self.world_info.clear()
        self.chapter_info.clear()
        self.chapter_info_without_repeatable.clear()
        self.get_world_info.cache_clear()
        self.parse()

    @staticmethod
    @lru_cache(maxsize=128)
    def get_world_info(map_id: str) -> dict:
        '''读取json文件内容，返回字典'''
        world_info = {}
        with open(MapParser.map_id_path[map_id], 'rb') as f:
            world_info = load(f)

        return world_info

    @staticmethod
    def get_world_all(c, user) -> list:
        '''
            读取所有地图信息，返回列表
            parameter: `user` - `User` 类或子类的实例
            `c` - 数据库连接
        '''
        return [UserMap(c, map_id, user) for map_id in MapParser.map_id_path.keys()]


class Step:
    '''台阶类'''

    def __init__(self) -> None:
        self.position: int = None
        self.capture: int = None
        self.items: list = []
        self.restrict_id: str = None
        self.restrict_ids: list = []
        self.restrict_type: str = None
        self.restrict_difficulty: int = None
        self.step_type: list = None
        self.speed_limit_value: int = None
        self.plus_stamina_value: int = None

    def to_dict(self) -> dict:
        r = {
            'position': self.position,
            'capture': self.capture,
        }
        if self.items:
            r['items'] = [i.to_dict() for i in self.items]
        if self.restrict_type:
            r['restrict_type'] = self.restrict_type
            if self.restrict_id:
                r['restrict_id'] = self.restrict_id
            if self.restrict_ids:
                r['restrict_ids'] = self.restrict_ids
            if self.restrict_difficulty is not None:
                r['restrict_difficulty'] = self.restrict_difficulty
        if self.step_type:
            r['step_type'] = self.step_type
        if self.speed_limit_value:
            r['speed_limit_value'] = self.speed_limit_value
        if self.plus_stamina_value:
            r['plus_stamina_value'] = self.plus_stamina_value

        return r

    def from_dict(self, d: dict) -> 'Step':
        self.position = d['position']
        self.capture = d['capture']
        self.restrict_id = d.get('restrict_id')
        self.restrict_ids = d.get('restrict_ids')
        self.restrict_type = d.get('restrict_type')
        self.restrict_difficulty = d.get('restrict_difficulty')
        self.step_type = d.get('step_type', [])
        self.speed_limit_value = d.get('speed_limit_value')
        self.plus_stamina_value = d.get('plus_stamina_value')
        if 'items' in d:
            self.items = [ItemFactory.from_dict(i) for i in d['items']]
        return self


class Map:
    def __init__(self, map_id: str = None) -> None:
        self.map_id: str = map_id
        self.is_legacy: bool = None
        self.is_beyond: bool = None
        self.is_breached: bool = None
        self.beyond_health: int = None
        self.character_affinity: list = []
        self.affinity_multiplier: list = []
        self.chapter: int = None
        self.available_from: int = None
        self.available_to: int = None
        self.is_repeatable: bool = None
        self.require_id: 'str | list[str]' = None
        self.require_type: str = None
        self.require_value: int = None
        self.coordinate: str = None
        self.custom_bg: str = None
        self.stamina_cost: int = None
        self.steps: list = []
        self.__rewards: list = None

        self.require_localunlock_songid: str = None
        self.require_localunlock_challengeid: str = None
        self.chain_info: dict = None

        # self.requires: list[dict] = None
        self.requires_any: 'list[dict]' = None

        self.disable_over: bool = None
        self.new_law: str = None

    @property
    def rewards(self) -> list:
        if self.__rewards is None:
            self.get_rewards()
        return self.__rewards

    def get_rewards(self) -> list:
        if self.steps:
            self.__rewards = []
            for step in self.steps:
                if step.items:
                    self.__rewards.append(
                        {'items': [i.to_dict() for i in step.items], 'position': step.position})
        return self.__rewards

    @property
    def step_count(self):
        return len(self.steps)

    def to_dict(self) -> dict:
        if self.chapter is None:
            self.select_map_info()
        r = {
            'map_id': self.map_id,
            'is_legacy': self.is_legacy,
            'is_beyond': self.is_beyond,
            'is_breached': self.is_breached,
            'beyond_health': self.beyond_health,
            'character_affinity': self.character_affinity,
            'affinity_multiplier': self.affinity_multiplier,
            'chapter': self.chapter,
            'available_from': self.available_from,
            'available_to': self.available_to,
            'is_repeatable': self.is_repeatable,
            'require_id': self.require_id,
            'require_type': self.require_type,
            'require_value': self.require_value,
            'coordinate': self.coordinate,
            'custom_bg': self.custom_bg,
            'stamina_cost': self.stamina_cost,
            'step_count': self.step_count,
            'require_localunlock_songid': self.require_localunlock_songid,
            'require_localunlock_challengeid': self.require_localunlock_challengeid,
            'steps': [s.to_dict() for s in self.steps],
        }
        if self.chain_info is not None:
            r['chain_info'] = self.chain_info
        if self.disable_over:
            r['disable_over'] = self.disable_over
        if self.new_law is not None and self.new_law != '':
            r['new_law'] = self.new_law
        if self.requires_any:
            r['requires_any'] = self.requires_any
        return r

    def from_dict(self, raw_dict: dict) -> 'Map':
        self.is_legacy = raw_dict.get('is_legacy', False)
        self.is_beyond = raw_dict.get('is_beyond', False)
        self.is_breached = raw_dict.get('is_breached', False)
        self.beyond_health = raw_dict.get('beyond_health')
        self.character_affinity = raw_dict.get('character_affinity', [])
        self.affinity_multiplier = raw_dict.get('affinity_multiplier', [])
        self.chapter = raw_dict.get('chapter')
        self.available_from = raw_dict.get('available_from', -1)
        self.available_to = raw_dict.get('available_to', 9999999999999)
        self.is_repeatable = raw_dict.get('is_repeatable')
        self.require_id = raw_dict.get('require_id', '')
        self.require_type = raw_dict.get('require_type', '')
        self.require_value = raw_dict.get('require_value', 1)
        self.coordinate = raw_dict.get('coordinate')
        self.custom_bg = raw_dict.get('custom_bg', '')
        self.stamina_cost = raw_dict.get('stamina_cost')
        self.require_localunlock_songid = raw_dict.get(
            'require_localunlock_songid', '')
        self.require_localunlock_challengeid = raw_dict.get(
            'require_localunlock_challengeid', '')
        self.chain_info = raw_dict.get('chain_info')
        self.steps = [Step().from_dict(s) for s in raw_dict.get('steps')]

        self.disable_over = raw_dict.get('disable_over')
        self.new_law = raw_dict.get('new_law')
        self.requires_any = raw_dict.get('requires_any')
        return self

    def select_map_info(self):
        '''获取地图信息'''
        self.from_dict(MapParser.get_world_info(self.map_id))


class UserMap(Map):
    '''
        用户地图类
        parameters: `user` - `User`类或者子类的实例
    '''

    def __init__(self, c=None, map_id: str = None, user=None) -> None:
        super().__init__(map_id)
        self.c = c
        self.curr_position: int = None
        self.curr_capture: int = None
        self.is_locked: bool = None

        self.prev_position: int = None
        self.prev_capture: int = None

        self.user = user

    @property
    def rewards_for_climbing(self) -> list:
        rewards = []
        for i in range(self.prev_position+1, self.curr_position+1):
            step = self.steps[i]
            if step.items:
                rewards.append(
                    {'items': step.items, 'position': step.position})

        return rewards

    def rewards_for_climbing_to_dict(self) -> list:
        rewards = []
        for i in range(self.prev_position+1, self.curr_position+1):
            step = self.steps[i]
            if step.items:
                rewards.append(
                    {'items': [i.to_dict() for i in step.items], 'position': step.position})

        return rewards

    @property
    def steps_for_climbing(self) -> list:
        return self.steps[self.prev_position:self.curr_position+1]

    def to_dict(self, has_map_info: bool = False, has_steps: bool = False, has_rewards: bool = False) -> dict:
        if self.is_locked is None:
            self.select()
        if has_map_info:
            if self.chapter is None:
                self.select_map_info()
            r = super().to_dict()
            r['curr_position'] = self.curr_position
            r['curr_capture'] = self.curr_capture
            r['is_locked'] = self.is_locked
            r['user_id'] = self.user.user_id
            # memory_boost_ticket
            if not has_steps:
                del r['steps']
            if has_rewards:
                r['rewards'] = self.rewards
        else:
            r = {
                'map_id': self.map_id,
                'curr_position': self.curr_position,
                'curr_capture': self.curr_capture,
                'is_locked': self.is_locked,
                'user_id': self.user.user_id,
            }
        return r

    def initialize(self):
        '''初始化数据库信息'''
        self.c.execute('''insert into user_world values(:a,:b,0,0,1)''', {
                       'a': self.user.user_id, 'b': self.map_id})

    def update(self):
        '''向数据库更新信息'''
        self.c.execute('''update user_world set curr_position=:a,curr_capture=:b,is_locked=:c where user_id=:d and map_id=:e''', {
                       'a': self.curr_position, 'b': self.curr_capture, 'c': 1 if self.is_locked else 0, 'd': self.user.user_id, 'e': self.map_id})

    def select(self):
        '''获取用户在此地图的信息'''
        self.c.execute('''select curr_position, curr_capture, is_locked from user_world where map_id = :a and user_id = :b''',
                       {'a': self.map_id, 'b': self.user.user_id})
        x = self.c.fetchone()
        if x:
            self.curr_position = x[0]
            self.curr_capture = x[1]
            self.is_locked = x[2] == 1
        else:
            self.curr_position = 0
            self.curr_capture = 0
            self.is_locked = True
            self.initialize()

    def change_user_current_map(self):
        '''改变用户当前地图为此地图'''
        self.user.current_map = self
        self.c.execute('''update user set current_map = :a where user_id=:b''', {
            'a': self.map_id, 'b': self.user.user_id})

    def unlock(self) -> bool:
        '''解锁用户此地图，返回成功与否bool值'''
        self.select()

        if self.is_locked:
            self.is_locked = False
            self.curr_position = 0
            self.curr_capture = 0
            self.select_map_info()
            if self.require_type is not None and self.require_type != '':
                if self.require_type in ['pack', 'single']:
                    item = ItemFactory(self.c).get_item(self.require_type)
                    item.item_id = self.require_id
                    item.select_user_item(self.user)
                    if not item.amount:
                        self.is_locked = True

            self.update()

        return not self.is_locked

    def climb(self, step_value: float) -> None:
        '''爬梯子，数值非负'''
        if step_value < 0:
            raise InputError('`Step_value` must be non-negative.')
        if self.curr_position is None:
            self.select()
        if self.is_beyond is None:
            self.select_map_info()
        if self.is_locked:
            raise MapLocked('The map is locked.')

        self.prev_capture = self.curr_capture
        self.prev_position = self.curr_position

        if self.is_beyond:  # beyond判断
            dt = self.beyond_health - self.prev_capture
            self.curr_capture = self.prev_capture + \
                step_value if dt >= step_value else self.beyond_health

            i = 0
            t = self.prev_capture + step_value
            while i < self.step_count and t > 0:
                dt = self.steps[i].capture
                if dt > t:
                    t = 0
                else:
                    t -= dt
                    i += 1
            if i >= self.step_count:
                self.curr_position = self.step_count - 1
            else:
                self.curr_position = i

        else:
            i = self.prev_position
            j = self.prev_capture
            t = step_value
            while t > 0 and i < self.step_count:
                dt = self.steps[i].capture - j
                if dt > t:
                    j += t
                    t = 0
                else:
                    t -= dt
                    j = 0
                    i += 1
            if i >= self.step_count:
                self.curr_position = self.step_count - 1
                self.curr_capture = 0
            else:
                self.curr_position = i
                self.curr_capture = j

    def reclimb(self, step_value: float) -> None:
        '''重新爬梯子计算'''
        self.curr_position = self.prev_position
        self.curr_capture = self.prev_capture
        self.climb(step_value)


class Stamina:
    '''
        体力类
    '''

    def __init__(self) -> None:
        self.__stamina: int = None
        self.max_stamina_ts: int = None

    def set_value(self, max_stamina_ts: int, stamina: int):
        self.max_stamina_ts = int(max_stamina_ts) if max_stamina_ts else 0
        self.__stamina = int(stamina) if stamina else Constant.MAX_STAMINA

    @property
    def stamina(self) -> int:
        '''通过计算得到当前的正确体力值'''
        stamina = round(Constant.MAX_STAMINA - (self.max_stamina_ts -
                                                int(time()*1000)) / Constant.STAMINA_RECOVER_TICK)

        if stamina >= Constant.MAX_STAMINA:
            if self.__stamina >= Constant.MAX_STAMINA:
                stamina = self.__stamina
            else:
                stamina = Constant.MAX_STAMINA

        return stamina

    @stamina.setter
    def stamina(self, value: int) -> None:
        '''设置体力值，此处会导致max_stamina_ts变化'''
        self.__stamina = round(value)
        self.max_stamina_ts = int(
            time()*1000) - (self.__stamina-Constant.MAX_STAMINA) * Constant.STAMINA_RECOVER_TICK


class UserStamina(Stamina):
    '''
        用户体力类

        parameter: `user` - `User`类或子类的实例
    '''

    def __init__(self, c=None, user=None) -> None:
        super().__init__()
        self.c = c
        self.user = user

    def select(self):
        '''获取用户体力信息'''
        self.c.execute('''select max_stamina_ts, staminafrom user where user_id = :a''',
                       {'a': self.user.user_id})
        x = self.c.fetchone()
        if not x:
            raise NoData('The user does not exist.')
        self.set_value(x[0], x[1])

    def update(self):
        '''向数据库更新信息'''
        self.c.execute('''update user set max_stamina_ts=:b, stamina=:a where user_id=:c''', {
                       'a': self.stamina, 'b': self.max_stamina_ts, 'c': self.user.user_id})


class WorldSkillMixin:
    '''
        不可实例化

        self.c = c
        self.user = user
        self.user_play = user_play
    '''

    def before_calculate(self) -> None:
        factory_dict = {
            'skill_vita': self._skill_vita,
            'skill_mika': self._skill_mika,
            'skill_ilith_ivy': self._skill_ilith_ivy,
            'ilith_awakened_skill': self._ilith_awakened_skill,
            'skill_hikari_vanessa': self._skill_hikari_vanessa,
            'skill_mithra': self._skill_mithra,
            'skill_chinatsu': self._skill_chinatsu,
            'skill_salt': self._skill_salt,
            'skill_hikari_selene': self._skill_hikari_selene,
            'skill_nami_sui': self._skill_nami_sui,
        }
        if self.user_play.beyond_gauge == 0 and self.character_used.character_id == 35 and self.character_used.skill_id_displayed:
            self._special_tempest()

        if self.character_used.skill_id_displayed in factory_dict:
            factory_dict[self.character_used.skill_id_displayed]()

    def after_climb(self) -> None:
        factory_dict = {
            'eto_uncap': self._eto_uncap,
            'ayu_uncap': self._ayu_uncap,
            'skill_fatalis': self._skill_fatalis,
            'skill_amane': self._skill_amane,
            'skill_maya': self._skill_maya,
            'luna_uncap': self._luna_uncap,
            'skill_kanae_uncap': self._skill_kanae_uncap,
            'skill_eto_hoppe': self._skill_eto_hoppe,
            'skill_intruder': self._skill_intruder,
        }
        if self.character_used.skill_id_displayed in factory_dict:
            factory_dict[self.character_used.skill_id_displayed]()

    def _special_tempest(self) -> None:
        '''风暴对立技能，prog随全角色等级提升'''
        if self.character_used.database_table_name == 'user_char_full':
            self.prog_tempest = 60
        else:
            self.c.execute(
                '''select sum(level) from user_char where user_id=?''', (self.user.user_id,))
            x = self.c.fetchone()
            self.prog_tempest = int(x[0]) / 10 if x else 0
        if self.prog_tempest > 60:
            self.prog_tempest = 60
        elif self.prog_tempest < 0:
            self.prog_tempest = 0

    def _skill_vita(self) -> None:
        '''
            vita技能，overdrive随回忆率提升，提升量最多为10
            此处采用线性函数
        '''
        self.over_skill_increase = 0
        if 0 < self.user_play.health <= 100:
            self.over_skill_increase = self.user_play.health / 10

    def _eto_uncap(self) -> None:
        '''eto觉醒技能，获得残片奖励时世界模式进度加7'''
        fragment_flag = False

        for i in self.user.current_map.rewards_for_climbing:
            for j in i['items']:
                if j.item_type == 'fragment':
                    fragment_flag = True
                    break
            if fragment_flag:
                break

        if fragment_flag:
            self.character_bonus_progress_normalized = Constant.ETO_UNCAP_BONUS_PROGRESS

        self.user.current_map.reclimb(self.final_progress)

    def _luna_uncap(self) -> None:
        '''luna觉醒技能，限制格开始时世界模式进度加 7，偷懒重爬（因为 map 信息还未获取）'''
        x: 'Step' = self.user.current_map.steps_for_climbing[0]
        if x.restrict_id and x.restrict_type:
            self.self.character_bonus_progress_normalized = Constant.LUNA_UNCAP_BONUS_PROGRESS
            self.user.current_map.reclimb(self.final_progress)

    def _ayu_uncap(self) -> None:
        '''ayu 觉醒技能，世界模式进度随机变动 [-5, -5]，但不会小于 0'''

        self.character_bonus_progress_normalized = randint(
            -Constant.AYU_UNCAP_BONUS_PROGRESS, Constant.AYU_UNCAP_BONUS_PROGRESS)

        if self.progress_normalized + self.character_bonus_progress_normalized < 0:
            self.character_bonus_progress_normalized = -self.progress_normalized

        self.user.current_map.reclimb(self.final_progress)

    def _skill_fatalis(self) -> None:
        '''hikari fatalis技能，世界模式超载，打完休息60分钟'''

        self.user.world_mode_locked_end_ts = int(
            time()*1000) + Constant.SKILL_FATALIS_WORLD_LOCKED_TIME
        self.user.update_user_one_column('world_mode_locked_end_ts')

    def _skill_amane(self) -> None:
        '''
        amane技能，起始格为限速或随机，成绩小于EX时，世界模式进度减半
        '''
        x: 'Step' = self.user.current_map.steps_for_climbing[0]
        if ('randomsong' in x.step_type or 'speedlimit' in x.step_type) and self.user_play.song_grade < 5:
            self.character_bonus_progress_normalized = -self.progress_normalized / 2
            self.user.current_map.reclimb(self.final_progress)

    def _ilith_awakened_skill(self) -> None:
        '''
        ilith 觉醒技能，曲目通关时步数+6，wiki 说是 prog 值+6
        '''
        if self.user_play.health > 0:
            self.prog_skill_increase = 6

    def _skill_mika(self) -> None:
        '''
        mika 技能，通关特定曲目能力值翻倍
        '''
        if self.user_play.song.song_id in Constant.SKILL_MIKA_SONGS and self.user_play.clear_type != 0:
            self.over_skill_increase = self.character_used.overdrive.get_value(
                self.character_used.level)
            self.prog_skill_increase = self.character_used.prog.get_value(
                self.character_used.level)

    def _skill_mithra(self) -> None:
        '''
        mithra 技能，每 150 combo 增加世界模式进度+1
        '''
        if self.user_play.combo_interval_bonus:
            self.character_bonus_progress_normalized = self.user_play.combo_interval_bonus

    def _skill_ilith_ivy(self) -> None:
        '''
        ilith & ivy 技能，根据 skill_cytusii_flag 来增加三个数值，最高生命每过 20 就对应数值 +10
        '''
        if not self.user_play.skill_cytusii_flag:
            return
        x = self.user_play.skill_cytusii_flag[:
                                              self.user_play.highest_health // 20]
        self.over_skill_increase = x.count('2') * 10
        self.prog_skill_increase = x.count('1') * 10

    def _skill_hikari_vanessa(self) -> None:
        '''
        hikari & vanessa 技能，根据 skill_cytusii_flag 来减少三个数值，最高生命每过 20 就对应数值 -10
        '''
        if not self.user_play.skill_cytusii_flag:
            return
        x = self.user_play.skill_cytusii_flag[:5 -
                                              self.user_play.lowest_health // 20]
        self.over_skill_increase = -x.count('2') * 10
        self.prog_skill_increase = -x.count('1') * 10

    def _skill_maya(self) -> None:
        '''
        maya 技能，skill_flag 为 1 时，世界模式进度翻倍
        '''
        if self.character_used.skill_flag:
            self.character_bonus_progress_normalized = self.progress_normalized
            self.user.current_map.reclimb(self.final_progress)
        self.character_used.change_skill_state()

    def _skill_kanae_uncap(self) -> None:
        '''
        kanae 觉醒技能，保存世界模式 progress 并在下次结算
        直接加减在 progress 最后
        技能存储 base_progress * PROG / 50，下一次消耗全部存储值（无视技能和搭档，但需要非技能隐藏状态）
        6.0 更新：需要体力消耗才存
        '''
        if self.user.current_map.stamina_cost > 0:
            self.kanae_stored_progress = self.progress_normalized
            self.user.current_map.reclimb(self.final_progress)

    def _skill_eto_hoppe(self) -> None:
        '''
        eto_hoppe 技能，体力大于等于 6 格时，世界进度翻倍
        '''
        if self.user.stamina.stamina >= 6:
            self.character_bonus_progress_normalized = self.progress_normalized
            self.user.current_map.reclimb(self.final_progress)

    def _skill_chinatsu(self) -> None:
        '''
        chinatsu 技能，hp 超过时提高搭档能力值
        '''
        _flag = self.user_play.skill_chinatsu_flag
        if not self.user_play.hp_interval_bonus or not _flag:
            return

        x = _flag[:min(len(_flag), self.user_play.hp_interval_bonus)]
        self.over_skill_increase = x.count('2') * 5
        self.prog_skill_increase = x.count('1') * 5

    def _skill_intruder(self) -> None:
        '''
        intruder 技能，夺舍后世界进度翻倍
        '''
        if self.user_play.invasion_flag:
            self.character_bonus_progress_normalized = self.progress_normalized
            self.user.current_map.reclimb(self.final_progress)

    def _skill_salt(self) -> None:
        '''
        salt 技能，根据单个章节地图的完成情况额外获得最高 10 的世界模式进度

        当前章节完成地图数 / 本章节总地图数（不含无限图）* 10
        '''
        if Config.CHARACTER_FULL_UNLOCK:
            self.character_bonus_progress_normalized = 10
            return

        kvd = UserKVTable(self.c, self.user.user_id, 'world')

        chapter_id = self.user.current_map.chapter
        count = kvd['chapter_complete_count', chapter_id] or 0
        total = len(MapParser.chapter_info_without_repeatable[chapter_id])
        if count > total:
            count = total

        radio = count / total if total else 1

        self.character_bonus_progress_normalized = 10 * radio

    def _skill_hikari_selene(self) -> None:
        '''
        hikari_selene 技能，曲目结算时每满一格收集条增加 2 step 与 2 overdrive
        '''
        self.over_skill_increase = 0
        self.prog_skill_increase = 0
        if 0 < self.user_play.health <= 100:
            self.over_skill_increase = int(self.user_play.health / 10) * 2
            self.prog_skill_increase = int(self.user_play.health / 10) * 2

    def _skill_nami_sui(self) -> None:
        '''
        nami & sui 技能，根据纯粹音符数与 FEVER 等级提高世界模式进度
        '''
        if self.user_play.fever_bonus is None:
            return

        self.character_bonus_progress_normalized = self.user_play.fever_bonus / 1000


class BaseWorldPlay(WorldSkillMixin):
    '''
        世界模式打歌类，处理特殊角色技能，联动UserMap和UserPlay

        parameter: `user` - `UserOnline`类或子类的实例
        'user_play` - `UserPlay`类的实例
    '''

    def __init__(self, c=None, user=None, user_play=None) -> None:
        self.c = c
        self.user = user
        self.user_play = user_play
        self.character_used = None

        self.character_bonus_progress_normalized: float = None

        # wpaid: str

    def to_dict(self) -> dict:
        arcmap: 'UserMap' = self.user.current_map
        r = {
            "rewards": arcmap.rewards_for_climbing_to_dict(),
            "exp": self.character_used.level.exp,
            "level": self.character_used.level.level,
            "base_progress": self.base_progress,
            "progress": self.final_progress,
            "user_map": {
                "user_id": self.user.user_id,
                "curr_position": arcmap.curr_position,
                "curr_capture": arcmap.curr_capture,
                "is_locked": arcmap.is_locked,
                "map_id": arcmap.map_id,
                "prev_capture": arcmap.prev_capture,
                "prev_position": arcmap.prev_position,
                "beyond_health": arcmap.beyond_health
            },
            "char_stats": {
                "character_id": self.character_used.character_id,
                "frag": self.character_used.frag_value,
                "prog": self.character_used.prog_value,
                "overdrive": self.character_used.overdrive_value
            },
            "current_stamina": self.user.stamina.stamina,
            "max_stamina_ts": self.user.stamina.max_stamina_ts,
            'world_mode_locked_end_ts': self.user.world_mode_locked_end_ts,
            'beyond_boost_gauge': self.user.beyond_boost_gauge,
            # 'wpaid': 'helloworld',  # world play id ???
            'progress_before_sub_boost': self.final_progress,
            'progress_sub_boost_amount': 0,
            # 'subscription_multiply'

            # lephon_final: bool  dynamic map info
            # lephon_active: bool  dynamic map info
            # 'steps_modified': False,
        }

        if self.character_used.skill_id_displayed == 'skill_maya':
            r['char_stats']['skill_state'] = self.character_used.skill_state

        if self.user_play.stamina_multiply != 1:
            r['stamina_multiply'] = self.user_play.stamina_multiply
        if self.user_play.fragment_multiply != 100:
            r['fragment_multiply'] = self.user_play.fragment_multiply
        if self.user_play.prog_boost_multiply != 0:  # 源韵强化
            r['prog_boost_multiply'] = self.user_play.prog_boost_multiply

        return r

    @property
    def beyond_boost_gauge_addition(self) -> float:
        # guessed by Lost-MSth
        return 2.45 * self.user_play.rating ** 0.5 + 27

    @property
    def step_times(self) -> float:
        raise NotImplementedError

    @property
    def exp_times(self) -> float:
        return self.user_play.stamina_multiply * (self.user_play.prog_boost_multiply / 100 + 1)

    @property
    def character_bonus_progress(self) -> float:
        return self.character_bonus_progress_normalized * self.step_times

    @property
    def base_progress(self) -> float:
        raise NotImplementedError

    @property
    def progress_normalized(self) -> float:
        raise NotImplementedError

    @property
    def final_progress(self) -> float:
        raise NotImplementedError

    def before_update(self) -> None:
        if self.user_play.prog_boost_multiply != 0:
            self.user.update_user_one_column('prog_boost', 0)

        self.user_play.clear_play_state()
        # self.user.select_user_about_world_play()

        self.character_used = Character()

        self.user.character.select_character_info()
        if not self.user.is_skill_sealed:
            self.character_used = self.user.character
            if self.user_play.beyond_gauge == 0 and self.user.kanae_stored_prog > 0:
                # 实在不想拆开了，在这里判断一下，注意这段不会在 BeyondWorldPlay 中执行
                self.kanae_added_progress = self.user.kanae_stored_prog

            if self.user_play.invasion_flag == 1 or (self.user_play.invasion_flag == 2 and self.user_play.health <= 0):
                # 这里硬编码了搭档 id 72
                self.character_used = UserCharacter(self.c, 72, self.user)
                self.character_used.select_character_info()
        else:
            self.character_used.character_id = self.user.character.character_id
            self.character_used.level.level = self.user.character.level.level
            self.character_used.level.exp = self.user.character.level.exp
            self.character_used.frag.set_parameter(50, 50, 50)
            self.character_used.prog.set_parameter(50, 50, 50)
            self.character_used.overdrive.set_parameter(50, 50, 50)

        # self.user.current_map.select_map_info()

    def after_update(self) -> None:

        for i in self.user.current_map.rewards_for_climbing:  # 物品分发
            for j in i['items']:
                j.c = self.c
                j.user_claim_item(self.user)

        x: 'Step' = self.user.current_map.steps_for_climbing[-1]
        if x.step_type:
            if 'plusstamina' in x.step_type and x.plus_stamina_value:
                # 体力格子
                self.user.stamina.stamina += x.plus_stamina_value
                self.user.stamina.update()

        # 角色升级
        if self.character_used.database_table_name == 'user_char':
            self.character_used.upgrade(
                self.user, self.exp_times*self.user_play.rating*6)

        if self.user.current_map.curr_position == self.user.current_map.step_count-1 and self.user.current_map.is_repeatable:  # 循环图判断
            self.user.current_map.curr_position = 0

        self.user.current_map.update()

        # 更新用户完成情况
        self.user.update_user_world_complete_info()

    def update(self) -> None:
        '''世界模式更新'''
        self.before_update()
        self.before_calculate()
        self.user.current_map.climb(self.final_progress)
        self.after_climb()
        self.after_update()


class WorldPlay(BaseWorldPlay):
    def __init__(self, c=None, user=None, user_play=None) -> None:
        super().__init__(c, user, user_play)

        self.prog_tempest: float = None
        self.prog_skill_increase: float = None

        self.kanae_added_progress: float = None  # 群愿往外拿
        self.kanae_stored_progress: float = None  # 往群愿里塞
        # self.user.kanae_stored_prog: float 群愿有的

    def to_dict(self) -> dict:
        r = super().to_dict()

        # 基础进度加上搭档倍数 不带 character_bonus_progress 但是带 kanae 技能
        r['progress_partial_after_stat'] = self.progress_normalized

        if self.character_bonus_progress_normalized is not None:
            r['character_bonus_progress'] = self.character_bonus_progress_normalized
            # 不懂为什么两个玩意一样
            r['character_bonus_progress_normalized'] = self.character_bonus_progress_normalized

        if self.prog_skill_increase is not None:
            r['char_stats']['prog_skill_increase'] = self.prog_skill_increase

        if self.prog_tempest is not None:
            r['char_stats']['prog'] += self.prog_tempest  # 没试过要不要这样
            r['char_stats']['prog_tempest'] = self.prog_tempest

        if self.kanae_added_progress is not None:
            r['kanae_added_progress'] = self.kanae_added_progress

        if self.kanae_stored_progress is not None:
            r['kanae_stored_progress'] = self.kanae_stored_progress

        r['partner_adjusted_prog'] = self.partner_adjusted_prog

        r["user_map"]["steps"] = [x.to_dict()
                                  for x in self.user.current_map.steps_for_climbing]
        return r

    @property
    def step_times(self) -> float:
        return self.user_play.stamina_multiply * self.user_play.fragment_multiply / 100 * (self.user_play.prog_boost_multiply / 100 + 1)

    @property
    def character_bonus_progress(self) -> float:
        return self.character_bonus_progress_normalized * self.step_times

    @property
    def base_progress(self) -> float:
        return 2.5 + 2.45 * self.user_play.rating**0.5

    @property
    def final_progress(self) -> float:
        return (self.progress_normalized + (self.character_bonus_progress_normalized or 0)) * self.step_times + (self.kanae_added_progress or 0) - (self.kanae_stored_progress or 0)

    @property
    def partner_adjusted_prog(self) -> float:
        prog = self.character_used.prog.get_value(
            self.character_used.level)
        if self.prog_tempest:
            prog += self.prog_tempest
        if self.prog_skill_increase:
            prog += self.prog_skill_increase
        return prog

    @property
    def progress_normalized(self) -> float:
        return self.base_progress * (self.partner_adjusted_prog / 50)

    def after_update(self) -> None:
        '''世界模式更新'''
        super().after_update()

        # 更新byd大招蓄力条
        self.user.beyond_boost_gauge += self.beyond_boost_gauge_addition
        self.user.beyond_boost_gauge = min(self.user.beyond_boost_gauge, 200)
        self.user.update_user_one_column(
            'beyond_boost_gauge', self.user.beyond_boost_gauge)

        # 更新kanae存储进度
        if self.kanae_stored_progress is not None:
            self.user.kanae_stored_prog = self.kanae_stored_progress
            self.user.update_user_one_column(
                'kanae_stored_prog', self.user.kanae_stored_prog)
            return
        if self.kanae_added_progress is None:
            return
        self.kanae_stored_progress = 0
        self.user.update_user_one_column('kanae_stored_prog', 0)


class BeyondWorldPlay(BaseWorldPlay):

    def __init__(self, c=None, user=None, user_play=None) -> None:
        super().__init__(c, user, user_play)
        self.over_skill_increase: float = None

    @property
    def step_times(self) -> float:
        return self.user_play.stamina_multiply * self.user_play.fragment_multiply / 100 * (1 + self.user_play.prog_boost_multiply / 100 + self.user_play.beyond_boost_gauge_usage / 100)

    @property
    def affinity_multiplier(self) -> float:
        if self.user.current_map.character_affinity is not None and self.character_used.character_id is not None and self.character_used.character_id in self.user.current_map.character_affinity:
            return self.user.current_map.affinity_multiplier[self.user.current_map.character_affinity.index(self.character_used.character_id)]
        return 1

    @property
    def base_progress(self) -> float:
        return self.user_play.rating**0.5 * 0.43 + (25/28 if self.user_play.clear_type == 0 else 75/28)

    @property
    def final_progress(self) -> float:
        return self.progress_normalized * self.step_times

    @property
    def progress_normalized(self) -> float:
        overdrive = self.character_used.overdrive_value
        if self.over_skill_increase:
            overdrive += self.over_skill_increase

        return self.base_progress * (overdrive / 50) * self.affinity_multiplier

    def to_dict(self) -> dict:
        r = super().to_dict()

        # byd 进度 没有加上源韵强化 和 boost 的数值
        r['pre_boost_progress'] = self.progress_normalized * \
            self.user_play.fragment_multiply / 100

        # r['partner_multiply'] = self.affinity_multiplier  # ?

        if self.over_skill_increase is not None:
            r['char_stats']['over_skill_increase'] = self.over_skill_increase

        r["user_map"]["steps"] = len(self.user.current_map.steps_for_climbing)

        r['affinity_multiply'] = self.affinity_multiplier
        if self.user_play.beyond_boost_gauge_usage != 0:
            r['beyond_boost_gauge_usage'] = self.user_play.beyond_boost_gauge_usage

        return r

    def after_update(self) -> None:
        super().after_update()
        if self.user_play.beyond_boost_gauge_usage != 0 and self.user_play.beyond_boost_gauge_usage <= self.user.beyond_boost_gauge:
            self.user.beyond_boost_gauge -= self.user_play.beyond_boost_gauge_usage
            if abs(self.user.beyond_boost_gauge) <= 1e-5:
                self.user.beyond_boost_gauge = 0
            self.user.update_user_one_column(
                'beyond_boost_gauge', self.user.beyond_boost_gauge)


class WorldLawMixin:
    def breached_before_calculate(self) -> None:
        factory_dict = {
            'over100_step50': self._over100_step50,
            'frag50': self._frag50,
            'lowlevel': self._lowlevel,
            'antiheroism': self._antiheroism
        }
        if self.user.current_map.new_law in factory_dict:
            factory_dict[self.user.current_map.new_law]()

    def _over100_step50(self) -> None:
        '''PROG = OVER + STEP / 2'''
        over = self.character_used.overdrive_value + self.over_skill_increase
        prog = self.character_used.prog_value + self.prog_skill_increase
        self.new_law_prog = over + prog / 2

    def _frag50(self) -> None:
        '''PROG x= FRAG'''
        self.new_law_prog = self.character_used.frag_value

    def _lowlevel(self) -> None:
        '''PROG x= max(1.0, 2.0 - 0.1 x LEVEL)'''
        self.new_law_prog = 50 * \
            max(1, 2 - 0.1 * self.character_used.level.level)

    def _antiheroism(self) -> None:
        '''PROG = OVER - ||OVER-FRAG|-|OVER-STEP||'''
        over = self.character_used.overdrive_value + self.over_skill_increase
        prog = self.character_used.prog_value + self.prog_skill_increase
        x = abs(over - self.character_used.frag_value)
        y = abs(over - prog)
        self.new_law_prog = over - abs(x - y)


class BreachedWorldPlay(BeyondWorldPlay, WorldLawMixin):
    def __init__(self, c=None, user=None, user_play=None) -> None:
        super().__init__(c, user, user_play)
        self.new_law_prog: float = None

    @property
    def new_law_multiply(self) -> float:
        if self.new_law_prog is None:
            return 1
        return self.new_law_prog / 50

    @property
    def affinity_multiplier(self) -> float:
        return 1

    @property
    def progress_normalized(self) -> float:
        if self.user.current_map.disable_over:
            return self.base_progress * self.new_law_multiply

        overdrive = self.character_used.overdrive_value
        if self.over_skill_increase:
            overdrive += self.over_skill_increase
        return self.base_progress * (overdrive / 50) * self.new_law_multiply

    def to_dict(self) -> dict:
        r = super().to_dict()
        r['new_law_multiply'] = self.new_law_multiply
        return r

    def update(self) -> None:
        self.before_update()
        self.before_calculate()
        self.breached_before_calculate()
        self.user.current_map.climb(self.final_progress)
        self.after_climb()
        self.after_update()

另外sql.py 中有一些 score 用的 sql 查询工具，他的逻辑比较复杂，import os
import sqlite3
import traceback
from atexit import register

from .config_manager import Config
from .constant import ARCAEA_LOG_DATBASE_VERSION, Constant
from .error import ArcError, InputError
from .util import parse_version


class Connect:
    # 数据库连接类，上下文管理
    logger = None

    def __init__(self, file_path: str = Constant.SQLITE_DATABASE_PATH, in_memory: bool = False, logger=None) -> None:
        """
            数据库连接，默认连接arcaea_database.db
            接受：文件路径
            返回：sqlite3连接操作对象
        """
        self.file_path = file_path
        self.in_memory: bool = in_memory
        if logger is not None:
            self.logger = logger

        self.conn: sqlite3.Connection = None
        self.c: sqlite3.Cursor = None

    def __enter__(self) -> sqlite3.Cursor:
        if self.in_memory:
            self.conn = sqlite3.connect(
                'file:arc_tmp?mode=memory&cache=shared', uri=True, timeout=10)
        else:
            self.conn = sqlite3.connect(self.file_path, timeout=10)
        self.c = self.conn.cursor()
        return self.c

    def __exit__(self, exc_type, exc_val, exc_tb) -> bool:
        flag = True
        if exc_type is not None:
            if issubclass(exc_type, ArcError):
                flag = False
            else:
                self.conn.rollback()

                self.logger.error(
                    traceback.format_exception(exc_type, exc_val, exc_tb))

        self.conn.commit()
        self.conn.close()

        return flag


class Query:
    '''查询参数类'''

    def __init__(self, query_able: list = None, fuzzy_query_able: list = None, sort_able: list = None) -> None:
        self.query_able: list = query_able  # None表示不限制
        self.fuzzy_query_able: list = fuzzy_query_able  # None表示不限制
        self.sort_able: list = sort_able

        self.__limit: int = -1
        self.__offset: int = 0

        # {'name': 'admin'} or {'name': ['admin', 'user']}
        self.__query: dict = {}
        self.__fuzzy_query: dict = {}  # {'name': 'dmi'}

        # [{'column': 'user_id', 'order': 'ASC'}, ...]
        self.__sort: list = []

    @property
    def limit(self) -> int:
        return self.__limit

    @limit.setter
    def limit(self, limit: int) -> None:
        if not isinstance(limit, int):
            raise InputError(api_error_code=-101)
        self.__limit = limit

    @property
    def offset(self) -> int:
        return self.__offset

    @offset.setter
    def offset(self, offset: int) -> None:
        if not isinstance(offset, int):
            raise InputError(api_error_code=-101)
        self.__offset = offset

    @property
    def query(self) -> dict:
        return self.__query

    @query.setter
    def query(self, query: dict) -> None:
        self.__query = {}
        self.query_append(query)

    def query_append(self, query: dict) -> None:
        if not isinstance(query, dict):
            raise InputError(api_error_code=-101)
        if self.query_able is not None and query and not set(query).issubset(set(self.query_able)):
            raise InputError(api_error_code=-102)
        if not self.__query:
            self.__query = query
        else:
            self.__query.update(query)

    @property
    def fuzzy_query(self) -> dict:
        return self.__fuzzy_query

    @fuzzy_query.setter
    def fuzzy_query(self, fuzzy_query: dict) -> None:
        self.__fuzzy_query = {}
        self.fuzzy_query_append(fuzzy_query)

    def fuzzy_query_append(self, fuzzy_query: dict) -> None:
        if not isinstance(fuzzy_query, dict):
            raise InputError(api_error_code=-101)
        if self.fuzzy_query_able is not None and fuzzy_query and not set(fuzzy_query).issubset(set(self.fuzzy_query_able)):
            raise InputError(api_error_code=-102)
        if not self.__fuzzy_query:
            self.__fuzzy_query = fuzzy_query
        else:
            self.__fuzzy_query.update(fuzzy_query)

    @property
    def sort(self) -> list:
        return self.__sort

    @sort.setter
    def sort(self, sort: list) -> None:
        if not isinstance(sort, list):
            raise InputError(api_error_code=-101)
        if self.sort_able is not None and sort:
            for x in sort:
                if not isinstance(x, dict):
                    raise InputError(api_error_code=-101)
                if 'column' not in x or x['column'] not in self.sort_able:
                    raise InputError(api_error_code=-103)
                if 'order' not in x:
                    x['order'] = 'ASC'
                else:
                    if x['order'] not in ['ASC', 'DESC']:
                        raise InputError(api_error_code=-104)
        self.__sort = sort

    def set_value(self, limit=-1, offset=0, query=None, fuzzy_query=None, sort=None) -> None:
        self.limit = limit
        self.offset = offset
        self.query = query if query is not None else {}
        self.fuzzy_query = fuzzy_query if fuzzy_query is not None else {}
        self.sort = sort if sort is not None else []

    def from_dict(self, d: dict) -> 'Query':
        self.set_value(d.get('limit', -1), d.get('offset', 0),
                       d.get('query', {}), d.get('fuzzy_query', {}), d.get('sort', []))
        return self

    def from_args(self, query: dict, limit: int = -1, offset: int = 0, sort: list = None, fuzzy_query: dict = None) -> 'Query':
        self.set_value(limit, offset, query, fuzzy_query, sort)
        return self


class Sql:
    '''
        数据库增查删改类
    '''

    def __init__(self, c=None) -> None:
        self.c = c

    @staticmethod
    def get_select_sql(table_name: str, target_column: list = None, query: 'Query' = None):
        '''拼接单表内行查询单句sql语句，返回语句和参数列表'''
        sql_list = []
        if not target_column:
            sql = f'select * from {table_name}'
        else:
            sql = f"select {', '.join(target_column)} from {table_name}"

        if query is None:
            return sql, sql_list

        where_key = []
        for k, v in query.query.items():
            if isinstance(v, list):
                where_key.append(f"{k} in ({','.join(['?'] * len(v))})")
                sql_list.extend(v)
            else:
                where_key.append(f'{k}=?')
                sql_list.append(v)

        for k, v in query.fuzzy_query.items():
            where_key.append(f'{k} like ?')
            sql_list.append(f'%{v}%')

        if where_key:
            sql += ' where '
            sql += ' and '.join(where_key)

        if query.sort:
            sql += ' order by ' + \
                ', '.join([x['column'] + ' ' + x['order'] for x in query.sort])

        if query.limit >= 0:
            sql += ' limit ? offset ?'
            sql_list.append(query.limit)
            sql_list.append(query.offset)

        return sql, sql_list

    @staticmethod
    def get_insert_sql(table_name: str, key: list = None, value_len: int = None, insert_type: str = None) -> str:
        '''拼接insert语句，请注意只返回sql语句，insert_type为replace或ignore'''
        if key is None:
            key = []
        insert_type = 'replace' if insert_type in [
            'replace', 'R', 'r', 'REPLACE'] else 'ignore'
        return ('insert into ' if insert_type is None else 'insert or ' + insert_type + ' into ') + table_name + ('(' + ','.join(key) + ')' if key else '') + ' values(' + ','.join(['?'] * (len(key) if value_len is None else value_len)) + ')'

    @staticmethod
    def get_update_sql(table_name: str, d: dict = None, query: 'Query' = None):
        if not d:
            return None
        sql_list = []
        sql = f"update {table_name} set {','.join([f'{k}=?' for k in d.keys()])}"
        sql_list.extend(d.values())

        if query is None:
            return sql, sql_list

        where_key = []
        for k, v in query.query.items():
            if isinstance(v, list):
                where_key.append(f"{k} in ({','.join(['?'] * len(v))})")
                sql_list.extend(v)
            else:
                where_key.append(f'{k}=?')
                sql_list.append(v)

        for k, v in query.fuzzy_query.items():
            where_key.append(f'{k} like ?')
            sql_list.append(f'%{v}%')

        if where_key:
            sql += ' where '
            sql += ' and '.join(where_key)

        return sql, sql_list

    @staticmethod
    def get_update_many_sql(table_name: str, key: list = None, where_key: list = None) -> str:
        '''拼接update语句，这里不用Query类，也不用字典，请注意只返回sql语句'''
        if not key or not where_key:
            return None
        return f"update {table_name} set {','.join([f'{k}=?' for k in key])} where {' and '.join([f'{k}=?' for k in where_key])}"

    @staticmethod
    def get_delete_sql(table_name: str, query: 'Query' = None):
        '''拼接删除语句，query中只有query和fuzzy_query会被处理'''
        sql = f'delete from {table_name}'

        if query is None:
            return sql, []

        sql_list = []
        where_key = []
        for k, v in query.query.items():
            if isinstance(v, list):
                where_key.append(f"{k} in ({','.join(['?'] * len(v))})")
                sql_list.extend(v)
            else:
                where_key.append(f'{k}=?')
                sql_list.append(v)

        for k, v in query.fuzzy_query.items():
            where_key.append(f'{k} like ?')
            sql_list.append(f'%{v}%')

        if where_key:
            sql += ' where '
            sql += ' and '.join(where_key)

        return sql, sql_list

    def select(self, table_name: str, target_column: list = None, query: 'Query' = None) -> list:
        '''单表内行select单句sql语句，返回fetchall数据'''
        sql, sql_list = self.get_select_sql(table_name, target_column, query)
        self.c.execute(sql, sql_list)
        return self.c.fetchall()

    def select_exists(self, table_name: str, target_column: list = None, query: 'Query' = None) -> bool:
        '''单表内行select exists单句sql语句，返回bool值'''
        sql, sql_list = self.get_select_sql(table_name, target_column, query)
        self.c.execute('select exists(' + sql + ')', sql_list)
        return self.c.fetchone() == (1,)

    def insert(self, table_name: str, key: list, value: tuple, insert_type: str = None) -> None:
        '''单行插入或覆盖插入，key传[]则为全部列，insert_type为replace或ignore'''
        self.c.execute(self.get_insert_sql(
            table_name, key, len(value), insert_type), value)

    def insert_many(self, table_name: str, key: list, value_list: list, insert_type: str = None) -> None:
        '''多行插入或覆盖插入，key传[]则为全部列，insert_type为replace或ignore'''
        if not value_list:
            return
        self.c.executemany(self.get_insert_sql(
            table_name, key, len(value_list[0]), insert_type), value_list)

    def update(self, table_name: str, d: dict, query: 'Query' = None) -> None:
        '''单表内行update单句sql语句'''
        if not d:
            return
        sql, sql_list = self.get_update_sql(table_name, d, query)
        self.c.execute(sql, sql_list)

    def update_many(self, table_name: str, key: list, value_list: list, where_key: list, where_value_list: list) -> None:
        '''单表内行update多句sql语句，这里不用Query类，也不用字典，要求值list长度一致，有点像insert_many'''
        if not key or not value_list or not where_key or not where_value_list or not len(key) == len(value_list[0]) or not len(where_key) == len(where_value_list[0]) or not len(value_list) == len(where_value_list):
            raise ValueError
        self.c.executemany(self.get_update_many_sql(
            table_name, key, where_key), [x + y for x, y in zip(value_list, where_value_list)])

    def delete(self, table_name: str, query: 'Query' = None) -> None:
        '''删除，query中只有query和fuzzy_query会被处理'''
        sql, sql_list = self.get_delete_sql(table_name, query)
        self.c.execute(sql, sql_list)

    def get_table_info(self, table_name: str):
        '''得到表结构，返回主键列表和字段名列表'''
        pk = []
        name = []

        self.c.execute(f'''pragma table_info ("{table_name}")''')  # 这里无法参数化
        x = self.c.fetchall()
        if x:
            for i in x:
                name.append(i[1])
                if i[5] != 0:
                    pk.append(i[1])

        return pk, name


class DatabaseMigrator:

    SPECIAL_UPDATE_VERSION = {
        '2.11.3.11': '_version_2_11_3_11',
        '2.11.3.13': '_version_2_11_3_13'
    }

    def __init__(self, c1_path: str, c2_path: str) -> None:
        self.c1_path = c1_path
        self.c2_path = c2_path

        self.c1 = None
        self.c2 = None

        self.tables = Constant.DATABASE_MIGRATE_TABLES

    @staticmethod
    def update_one_table(c1, c2, table_name: str) -> bool:
        '''从c1向c2更新数据表，c1中存在的信息不变，即c2中的冲突信息会被覆盖'''
        c1.execute(
            '''select * from sqlite_master where type = 'table' and name = :a''', {'a': table_name})
        c2.execute(
            '''select * from sqlite_master where type = 'table' and name = :a''', {'a': table_name})
        if not c1.fetchone() or not c2.fetchone():
            return False

        sql1 = Sql(c1)
        sql2 = Sql(c2)
        db1_pk, db1_name = sql1.get_table_info(table_name)
        db2_pk, db2_name = sql2.get_table_info(table_name)
        if db1_pk != db2_pk:
            return False

        public_column = list(filter(lambda x: x in db2_name, db1_name))

        sql2.insert_many(table_name, public_column, sql1.select(
            table_name, public_column), insert_type='replace')

        return True

    @staticmethod
    def update_user_char_full(c) -> None:
        '''用character表数据更新user_char_full'''
        c.execute('''select character_id, max_level, is_uncapped from character''')
        x = c.fetchall()
        c.execute('''select user_id from user''')
        y = c.fetchall()
        c.execute('''delete from user_char_full''')
        for i in x:
            exp = 25000 if i[1] == 30 else 10000
            c.executemany('''insert into user_char_full values(?,?,?,?,?,?,0)''', [
                          (j[0], i[0], i[1], exp, i[2], 0) for j in y])

    def update_database(self) -> None:
        '''
        将c1数据库不存在数据加入或覆盖到c2数据库上
        对于c2，更新一些表，并用character数据更新user_char_full
        '''
        with Connect(self.c2_path) as c2:
            with Connect(self.c1_path) as c1:
                self.c1 = c1
                self.c2 = c2
                self.special_update()

                for i in self.tables:
                    self.update_one_table(c1, c2, i)

                if not Constant.UPDATE_WITH_NEW_CHARACTER_DATA:
                    self.update_one_table(c1, c2, 'character')

            self.update_user_char_full(c2)  # 更新user_char_full

    def special_update(self):
        old_version = self.c1.execute(
            '''select value from config where id = "version"''').fetchone()
        new_version = self.c2.execute(
            '''select value from config where id = "version"''').fetchone()
        old_version = old_version[0] if old_version else '0.0.0'
        new_version = new_version[0] if new_version else '0.0.0'
        old_version = parse_version(old_version)
        new_version = parse_version(new_version)

        for k, v in self.SPECIAL_UPDATE_VERSION.items():
            if old_version < parse_version(k) <= new_version:
                getattr(self, v)()

    def _version_2_11_3_11(self):
        '''
        2.11.3.11 版本特殊更新，调整 recent30 表结构
        recent30 表从 (user_id: int PK, rating<index>: real, song_id<index>: text, ...) \
        更改为 (user_id: int PK, r_index: int PK, time_played: int, song_id: text, difficulty: int, score: int, sp, p, n, m, hp, mod, clear_type, rating: real)
        '''

        self.tables = [x for x in self.tables if x != 'recent30']

        x = self.c1.execute('''select * from recent30''')
        sql_list = []
        for i in x:
            user_id = int(i[0])
            for j in range(30):
                rating = i[1 + j * 2]
                rating = float(rating) if rating else 0
                song_id_difficulty: str = i[2 + j * 2]
                if song_id_difficulty:
                    song_id = song_id_difficulty[:-1]
                    difficulty = song_id_difficulty[-1]
                    difficulty = int(difficulty) if difficulty.isdigit() else 0
                else:
                    song_id = ''
                    difficulty = 0

                sql_list.append(
                    (user_id, j, 100-j, song_id, difficulty, rating))

        self.c2.executemany(
            '''insert into recent30(user_id, r_index, time_played, song_id, difficulty, rating) values(?,?,?,?,?,?)''', sql_list)

    def _version_2_11_3_13(self):
        '''
        2.11.3.13 版本特殊更新，world_rank_score 机制调整，需清空用户分数
        '''
        self.c1.execute('''update user set world_rank_score = 0''')


class LogDatabaseMigrator:

    def __init__(self, c1_path: str = Config.SQLITE_LOG_DATABASE_PATH) -> None:
        self.c1_path = c1_path
        # self.c2_path = c2_path
        self.init_folder_path = Config.DATABASE_INIT_PATH
        self.c = None

    @property
    def sql_path(self) -> str:
        return os.path.join(self.init_folder_path, 'log_tables.sql')

    def table_update(self) -> None:
        '''直接更新数据库结构'''
        with open(self.sql_path, 'r') as f:
            self.c.executescript(f.read())
        self.c.execute(
            '''insert or replace into cache values("version", :a, -1);''', {'a': ARCAEA_LOG_DATBASE_VERSION})

    def update_database(self) -> None:
        with Connect(self.c1_path) as c:
            self.c = c
            self.table_update()


class MemoryDatabase:
    conn = sqlite3.connect('file:arc_tmp?mode=memory&cache=shared', uri=True)

    def __init__(self):
        self.c = self.conn.cursor()
        self.c.execute('''PRAGMA journal_mode = OFF''')
        self.c.execute('''PRAGMA synchronous = 0''')
        self.c.execute('''create table if not exists download_token(user_id int,
        song_id text,file_name text,token text,time int,primary key(user_id, song_id, file_name));''')
        self.c.execute('''create table if not exists bundle_download_token(token text primary key,
                       file_path text, time int, device_id text);''')
        self.c.execute(
            '''create index if not exists download_token_1 on download_token (song_id, file_name);''')
        self.c.execute('''
            create table if not exists notification(
                user_id int, id int,
                type text, content text,
                sender_user_id int, sender_name text,
                timestamp int,
                primary key(user_id, id)
            )
        ''')
        self.conn.commit()


@register
def atexit():
    MemoryDatabase.conn.close()


class UserKVTable:
    '''用户键值对表'''

    def __init__(self, c=None, user_id: int = None, class_name: str = None) -> None:
        self.c = c
        self.user_id = user_id
        self.class_name = class_name

    def get(self, key: str, idx: int = 0):
        '''获取键值对'''
        x = self.c.execute(
            '''select value from user_kvdata where user_id = ? and class = ? and key = ? and idx = ?''', (self.user_id, self.class_name, key, idx)).fetchone()
        return x[0] if x else None

    def set(self, key: str, value, idx: int = 0) -> None:
        '''设置键值对'''
        self.c.execute('''insert or replace into user_kvdata values(?,?,?,?,?)''',
                       (self.user_id, self.class_name, key, idx, value))

    def __getitem__(self, args):
        if isinstance(args, tuple):
            return self.get(*args)
        else:
            return self.get(args)

    def __setitem__(self, args, value):
        if isinstance(args, tuple):
            self.set(args[0], value, args[1])
        else:
            self.set(args, value)

最后我还是强调，请一定要使用宏而不是函数。另外请至少阅读我写的一个route 案例来看看例如 success_return 的使用等等。因为保持整个项目的风格一致性非常重要。

如果你需要测试接口，可以使用
curl -X GET "http://localhost:8090/yinmo/30/world/map/me" -H "Authorization: Bearer WUmp21svCqUa9BDa8NLo0r+494AAtn2xhH99IJskfEs="进行测试，这个 token 是有效的。
