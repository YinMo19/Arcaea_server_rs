我正在打算用 rust 重写一个 python flask 实现的后端服务。我已经简单构想了整个项目的模样，我想让你阅读 python 源代码并帮我实现。一些结构上和基础内容：

数据库方面，我打算使用 mariadb，并使用 sqlx 操作。我希望你尽量使用 query! query_as! query_scale!宏，在编译期判断 sql 正确性，并且尽可能的使用 struct 直接映射到 sql 内部的表格，而非使用 row.get 获取，因此我可以给你一个 mysql://arcaea:yinmo19sprivite@localhost:3306/arcaea_core 这样的实际可用的 mariadb 实例供参考。 另外数据库结构我已经设计好了（从 python 版本相似的结构） 我会在下面列出整个数据库迁移作为整个数据库结构, 你需要根据这个数据库结构来写 sql。另外我已经完成了迁移。

python 版本在 py_version文件夹内，这个文件夹目前处于 gitignore 状态，你使用 function call 可能无法 grep 其中内容，想要查找文件或者查找内容直接使用命令行的 grep 和 find。你必须阅读 python 的代码 ，每一行和每一个实现都完全摸清了才能开始写 rust 版本的内容，由于提前约定好了 api，因此你必须保证 python 版本的 api 和 rust 版本的 api 完全一致，不能有任何区别，否则将会引起错误。

关于 python 版本的结构，路由相关的文件在 server 文件夹下面，而核心逻辑在 core 下面。你必须要保证我的路由和 server 下面定义的路由完全一致，而我的 service 逻辑和 python 版本的 core 逻辑一致。

一些结构上的想法（已经初步实现，你需要保证与之前实现的一致性）：我希望你去阅读 python 版本的错误，并根据他的错误处理方式来专门给我产生处理错误的文件。我期望你使用 thiserror 来处理所有错误。所有 api 最后都返回 result T, ArcError 这里的 错误是 thiserror 的一个 enum。  除此之外，我希望我的整个项目是一个 service 和 route 分离的结构。我希望这样，一个 service 文件夹和一个 route 文件夹，以及一个对应的 model 文件，分别处理主要逻辑，路由以及数据库对应的结构。python 的代码是正确的实现，你只需要根据 python 的逻辑完成 rust 的重写即可。代码风格上保持和现有代码一致，我的一个要求是尽量把所有 struct 全部放在对应的 model 内， service 单文件不超过 1000 行。常量模块在 lib.rs 和 config.rs 里面均有定义，如需可查看。如果你需要获取客户端 ip，我已经完成了一个 ctx 可以让你作为 guard 直接使用，获取客户 ip 和其他信息，具体可以在 context.rs 查看。

最后我的要求是，你要假设你是 linus，对代码的要求是简洁和可用性高于一切。 所有对函数的详细文档都直接写在 rust 函数的上方的函数文档内，对功能进行详细描述即可。不要另外开 markdown 来写文档，毫无必要，任何进展直接告诉我即可。
 在写完之后记得 cargo check 保证能够过编译。如果你确认能过通过编译，那么可以进行测试，如果你需要测试，直接用最简单的 curl -X POST "http://localhost:8090/user" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "name=ciallo" \
     -d "password=0d000721" \
     -d "email=arcaea@yinmo19.top" \
     -d "device_id=0ed5525d2a77e201" 这样的 curl 直接使用命令行测试，如果你需要 token，curl -X POST "http://localhost:8090/auth/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -H "Authorization: Basic Y2lhbGxvOjBkMDAwNzIx" \
     -d "grant_type=client_credentials" 可以获取到你需要的 token。

我已经在后台使用 cargo watch 跑起来一个最新的案例，保证能够编译就自然是最新的，你可以放心的直接 curl 来看看结果如何，不要自己运行实例。不要新开任何的 test 文件来写一些毫无用处的测试。如果你认为你的 curl 足够简单，就像我给的案例这样，你可以放在 scripts 下面，每个 curl 一个sh文件，上面的案例在 register.sh 内。不要写任何的echo... 一个 sh 文件不超过五个 curl命令，不超过 20 行。

python 版本无论多复杂都不允许你做任何简化，除非你能保证最后逻辑结果完全一致，否则保持一模一样的实现，不要自作聪明。对于暂时无法完成的模块允许使用 todo 保留，但是尽量完成。

数据库迁移文件如下
-- MariaDB migration from SQLite
CREATE TABLE IF NOT EXISTS config (id VARCHAR(255) PRIMARY KEY, value TEXT);

CREATE TABLE user (
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(255) UNIQUE,
  password TEXT,
  join_date BIGINT,
  user_code VARCHAR(255),
  rating_ptt INT,
  character_id INT,
  is_skill_sealed TINYINT,
  is_char_uncapped TINYINT,
  is_char_uncapped_override TINYINT,
  is_hide_rating TINYINT,
  song_id TEXT,
  difficulty INT,
  score INT,
  shiny_perfect_count INT,
  perfect_count INT,
  near_count INT,
  miss_count INT,
  health INT,
  modifier INT,
  time_played BIGINT,
  clear_type INT,
  rating DOUBLE,
  favorite_character INT,
  max_stamina_notification_enabled TINYINT,
  current_map TEXT,
  ticket INT,
  prog_boost INT,
  email VARCHAR(255),
  world_rank_score INT,
  ban_flag TEXT,
  next_fragstam_ts BIGINT,
  max_stamina_ts BIGINT,
  stamina INT,
  world_mode_locked_end_ts BIGINT,
  beyond_boost_gauge DOUBLE DEFAULT 0,
  kanae_stored_prog DOUBLE DEFAULT 0,
  mp_notification_enabled TINYINT DEFAULT 1,
  highest_rating_ptt INT DEFAULT 0,
  insight_state INT DEFAULT 4
);

CREATE TABLE IF NOT EXISTS login (
  access_token TEXT,
  user_id INT,
  login_time BIGINT,
  login_ip TEXT,
  login_device TEXT,
  PRIMARY KEY (access_token (255), user_id)
);

CREATE TABLE IF NOT EXISTS friend (
  user_id_me INT,
  user_id_other INT,
  PRIMARY KEY (user_id_me, user_id_other)
);

CREATE TABLE IF NOT EXISTS best_score (
  user_id INT,
  song_id VARCHAR(255),
  difficulty INT,
  score INT,
  shiny_perfect_count INT,
  perfect_count INT,
  near_count INT,
  miss_count INT,
  health INT,
  modifier INT,
  time_played BIGINT,
  best_clear_type INT,
  clear_type INT,
  rating DOUBLE DEFAULT 0,
  score_v2 DOUBLE DEFAULT 0,
  PRIMARY KEY (user_id, song_id, difficulty)
);

CREATE TABLE IF NOT EXISTS `character` (
  character_id INT PRIMARY KEY,
  name TEXT,
  max_level INT,
  frag1 DOUBLE,
  prog1 DOUBLE,
  overdrive1 DOUBLE,
  frag20 DOUBLE,
  prog20 DOUBLE,
  overdrive20 DOUBLE,
  frag30 DOUBLE,
  prog30 DOUBLE,
  overdrive30 DOUBLE,
  skill_id TEXT,
  skill_unlock_level INT,
  skill_requires_uncap TINYINT,
  skill_id_uncap TEXT,
  char_type INT,
  is_uncapped TINYINT
);

CREATE TABLE IF NOT EXISTS user_char (
  user_id INT NOT NULL,
  character_id INT NOT NULL,
  level INT,
  exp DOUBLE,
  is_uncapped TINYINT,
  is_uncapped_override TINYINT,
  skill_flag INT,
  FOREIGN KEY (user_id) REFERENCES user (user_id),
  FOREIGN KEY (character_id) REFERENCES `character` (character_id)
);

CREATE TABLE IF NOT EXISTS user_char_full (
  user_id INT NOT NULL,
  character_id INT NOT NULL,
  level INT,
  exp DOUBLE,
  is_uncapped TINYINT,
  is_uncapped_override TINYINT,
  skill_flag INT,
  FOREIGN KEY (user_id) REFERENCES user (user_id),
  FOREIGN KEY (character_id) REFERENCES `character` (character_id)
);

CREATE TABLE IF NOT EXISTS char_item (
  character_id INT,
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (character_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS recent30 (
  user_id INT,
  r_index INT,
  time_played BIGINT,
  song_id VARCHAR(255),
  difficulty INT,
  score INT DEFAULT 0,
  shiny_perfect_count INT DEFAULT 0,
  perfect_count INT DEFAULT 0,
  near_count INT DEFAULT 0,
  miss_count INT DEFAULT 0,
  health INT DEFAULT 0,
  modifier INT DEFAULT 0,
  clear_type INT DEFAULT 0,
  rating DOUBLE DEFAULT 0,
  PRIMARY KEY (user_id, r_index)
);

CREATE TABLE IF NOT EXISTS user_world (
  user_id INT,
  map_id VARCHAR(255),
  curr_position INT,
  curr_capture DOUBLE,
  is_locked TINYINT,
  PRIMARY KEY (user_id, map_id)
);

CREATE TABLE IF NOT EXISTS songplay_token (
  token VARCHAR(255) PRIMARY KEY,
  user_id INT,
  song_id VARCHAR(255),
  difficulty INT,
  course_id VARCHAR(255),
  course_state INT,
  course_score INT,
  course_clear_type INT,
  stamina_multiply INT,
  fragment_multiply INT,
  prog_boost_multiply INT,
  beyond_boost_gauge_usage INT,
  skill_cytusii_flag TEXT,
  skill_chinatsu_flag TEXT,
  invasion_flag INT
);

CREATE TABLE IF NOT EXISTS item (
  item_id VARCHAR(255),
  type VARCHAR(255),
  is_available TINYINT,
  PRIMARY KEY (item_id, type)
);

CREATE TABLE IF NOT EXISTS user_item (
  user_id INT,
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (user_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS purchase (
  purchase_name VARCHAR(255) PRIMARY KEY,
  price INT,
  orig_price INT,
  discount_from BIGINT,
  discount_to BIGINT,
  discount_reason TEXT
);

CREATE TABLE IF NOT EXISTS purchase_item (
  purchase_name VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (purchase_name, item_id, type)
);

CREATE TABLE IF NOT EXISTS user_save (
  user_id INT PRIMARY KEY,
  scores_data TEXT,
  clearlamps_data TEXT,
  clearedsongs_data TEXT,
  unlocklist_data TEXT,
  installid_data TEXT,
  devicemodelname_data TEXT,
  story_data TEXT,
  createdAt BIGINT,
  finalestate_data TEXT
);

CREATE TABLE IF NOT EXISTS present (
  present_id VARCHAR(255) PRIMARY KEY,
  expire_ts BIGINT,
  description TEXT
);

CREATE TABLE IF NOT EXISTS user_present (
  user_id INT,
  present_id VARCHAR(255),
  PRIMARY KEY (user_id, present_id)
);

CREATE TABLE IF NOT EXISTS present_item (
  present_id VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (present_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS chart (
  song_id VARCHAR(255) PRIMARY KEY,
  name TEXT,
  rating_pst INT DEFAULT -1,
  rating_prs INT DEFAULT -1,
  rating_ftr INT DEFAULT -1,
  rating_byn INT DEFAULT -1,
  rating_etr INT DEFAULT -1
);

CREATE TABLE IF NOT EXISTS redeem (code VARCHAR(255) PRIMARY KEY, type INT);

CREATE TABLE IF NOT EXISTS user_redeem (
  user_id INT,
  code VARCHAR(255),
  PRIMARY KEY (user_id, code)
);

CREATE TABLE IF NOT EXISTS redeem_item (
  code VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (code, item_id, type)
);

CREATE TABLE IF NOT EXISTS role (role_id VARCHAR(255) PRIMARY KEY, caption TEXT);

CREATE TABLE IF NOT EXISTS user_role (
  user_id INT,
  role_id VARCHAR(255),
  PRIMARY KEY (user_id, role_id)
);

CREATE TABLE IF NOT EXISTS power(power_id VARCHAR(255) PRIMARY KEY, caption TEXT);

CREATE TABLE IF NOT EXISTS role_power (
  role_id VARCHAR(255),
  power_id VARCHAR(255),
  PRIMARY KEY (role_id, power_id)
);

CREATE TABLE IF NOT EXISTS api_login (
  user_id INT,
  token VARCHAR(255),
  login_time BIGINT,
  login_ip TEXT,
  PRIMARY KEY (user_id, token)
);

CREATE TABLE IF NOT EXISTS course (
  course_id VARCHAR(255) PRIMARY KEY,
  course_name TEXT,
  dan_name TEXT,
  style INT,
  gauge_requirement TEXT,
  flag_as_hidden_when_requirements_not_met TINYINT,
  can_start TINYINT
);

CREATE TABLE IF NOT EXISTS user_course (
  user_id INT,
  course_id VARCHAR(255),
  high_score INT,
  best_clear_type INT,
  PRIMARY KEY (user_id, course_id)
);

CREATE TABLE IF NOT EXISTS course_chart (
  course_id VARCHAR(255),
  song_id VARCHAR(255),
  difficulty INT,
  flag_as_hidden TINYINT,
  song_index INT,
  PRIMARY KEY (course_id, song_index)
);

CREATE TABLE IF NOT EXISTS course_requirement (
  course_id VARCHAR(255),
  required_id VARCHAR(255),
  PRIMARY KEY (course_id, required_id)
);

CREATE TABLE IF NOT EXISTS course_item (
  course_id VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (course_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS user_mission (
  user_id INT,
  mission_id VARCHAR(255),
  status INT,
  PRIMARY KEY (user_id, mission_id)
);

CREATE TABLE IF NOT EXISTS user_kvdata (
  user_id INT,
  class VARCHAR(255),
  `key` VARCHAR(255),
  idx INT,
  value TEXT,
  PRIMARY KEY (user_id, class, `key`, idx)
);

CREATE INDEX IF NOT EXISTS best_score_1 ON best_score (song_id, difficulty);

CREATE TABLE IF NOT EXISTS user_custom_course (
  user_id INT,
  custom_course TEXT,
  PRIMARY KEY (user_id)
);

CREATE TABLE IF NOT EXISTS download_token (
  user_id INT,
  song_id VARCHAR(255),
  file_name VARCHAR(255),
  token VARCHAR(255),
  time BIGINT,
  PRIMARY KEY (user_id, song_id, file_name)
);


-- Add notification and bundle download tables
CREATE TABLE IF NOT EXISTS notification (
  user_id INT,
  id INT,
  type VARCHAR(255),
  content TEXT,
  sender_user_id INT,
  sender_name VARCHAR(255),
  timestamp BIGINT,
  PRIMARY KEY (user_id, id)
);

CREATE TABLE IF NOT EXISTS bundle_download_token (
  token VARCHAR(255) PRIMARY KEY,
  file_path TEXT,
  time BIGINT,
  device_id VARCHAR(255)
);
这是所有数据库接口，你无需再阅读现有的数据库迁移。

下面是我需要你帮我实现的目标：

我认为我目前的实现还有一些问题，所以我请你帮我检验一下我的score。我希望你这样检验我的代码：先阅读 route/score.rs ，知道我的路由有哪些，然后阅读 server/score.py 知道我的路由和 python 是匹配的（这个我已经检查过了）然后接下来，对每一个路由进行检查。请一个个完成。看到路由，然后看看路由函数做了什么，然后去检查调用的函数，然后看看做了什么，然后去看看 python 版本是怎么完成的。由于 score 系统需要阅读 chart 的内容以及排序 rank，所以实际上调用的函数多而杂（尤其会涉及到 sql.py 的内容，python 版本对 sql 查询做了一些封装），请递归阅读所有实现，然后帮我把我的逻辑完成。
