我正在打算用 rust 重写一个 python flask 实现的后端服务。我已经简单构想了整个项目的模样，我想让你阅读 python 源代码并帮我实现。一些结构上和基础内容：

数据库方面，我打算使用 mariadb，并使用 sqlx 操作。我希望你尽量使用 query! query_as! query_scale!宏，在编译期判断 sql 正确性，并且尽可能的使用 struct 直接映射到 sql 内部的表格，而非使用 row.get 获取，因此我可以给你一个 mysql://arcaea:yinmo19sprivite@localhost:3306/arcaea_core 这样的实际可用的 mariadb 实例供参考。 另外数据库结构我已经设计好了（从 python 版本相似的结构） 我会在下面列出整个数据库迁移作为整个数据库结构, 你需要根据这个数据库结构来写 sql。另外我已经完成了迁移。

python 版本在 py_version文件夹内，这个文件夹目前处于 gitignore 状态，你是用 function call 可能无法 grep 其中内容，想要查找文件或者查找内容直接使用命令行的 grep 和 find。你必须阅读 python 的代码 ，每一行和每一个实现都完全摸清了才能开始写 rust 版本的内容，由于提前约定好了 api，因此你必须保证 python 版本的 api 和 rust 版本的 api 完全一致，不能有任何区别，否则将会引起错误。

关于 python 版本的结构，路由相关的文件在 server 文件夹下面，而核心逻辑在 core 下面。你必须要保证我的路由和 server 下面定义的路由完全一致，而我的 service 逻辑和 python 版本的 core 逻辑一致。

一些结构上的想法（已经初步实现，你需要保证与之前实现的一致性）：我希望你去阅读 python 版本的错误，并根据他的错误处理方式来专门给我产生处理错误的文件。我期望你使用 thiserror 来处理所有错误。所有 api 最后都返回 result T, ArcError 这里的 错误是 thiserror 的一个 enum。  除此之外，我希望我的整个项目是一个 service 和 route 分离的结构。我希望这样，一个 service 文件夹和一个 route 文件夹，以及一个对应的 model 文件，分别处理主要逻辑，路由以及数据库对应的结构。python 的代码是正确的实现，你只需要根据 python 的逻辑完成 rust 的重写即可。代码风格上保持和现有代码一致，我的一个要求是尽量把所有 struct 全部放在对应的 model 内， service 单文件不超过 1000 行。常量模块在 lib.rs 和 config.rs 里面均有定义，如需可查看。如果你需要获取客户端 ip，我已经完成了一个 ctx 可以让你作为 guard 直接使用，获取客户 ip 和其他信息，具体可以在 context.rs 查看。

最后我的要求是，你要假设你是 linus，对代码的要求是简洁和可用性高于一切。 所有对函数的详细文档都直接写在 rust 函数的上方的函数文档内，对功能进行详细描述即可。不要另外开 markdown 来写文档，毫无必要，任何进展直接告诉我即可。
 在写完之后记得 cargo check 保证能够过编译。如果你确认能过通过编译，那么可以进行测试，如果你需要测试，直接用最简单的 curl -X POST "http://localhost:8090/user" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "name=ciallo" \
     -d "password=0d000721" \
     -d "email=arcaea@yinmo19.top" \
     -d "device_id=0ed5525d2a77e201" 这样的 curl 直接使用命令行测试，如果你需要 token，curl -X POST "http://localhost:8090/auth/login" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -H "Authorization: Basic Y2lhbGxvOjBkMDAwNzIx" \
     -d "grant_type=client_credentials" 可以获取到你需要的 token。

我已经在后台使用 cargo watch 跑起来一个最新的案例，保证能够编译就自然是最新的，你可以放心的直接 curl 来看看结果如何，不要自己运行实例。不要新开任何的 test 文件来写一些毫无用处的测试。如果你认为你的 curl 足够简单，就像我给的案例这样，你可以放在 scripts 下面，每个 curl 一个sh文件，上面的案例在 register.sh 内。不要写任何的echo... 一个 sh 文件不超过五个 curl命令，不超过 20 行。

python 版本无论多复杂都不允许你做任何简化，除非你能保证最后逻辑结果完全一致，否则保持一模一样的实现，不要自作聪明。对于暂时无法完成的模块允许使用 todo 保留，但是尽量完成。

数据库迁移文件如下
-- MariaDB migration from SQLite
CREATE TABLE IF NOT EXISTS config (id VARCHAR(255) PRIMARY KEY, value TEXT);

CREATE TABLE user (
  user_id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(255) UNIQUE,
  password TEXT,
  join_date BIGINT,
  user_code VARCHAR(255),
  rating_ptt INT,
  character_id INT,
  is_skill_sealed TINYINT,
  is_char_uncapped TINYINT,
  is_char_uncapped_override TINYINT,
  is_hide_rating TINYINT,
  song_id TEXT,
  difficulty INT,
  score INT,
  shiny_perfect_count INT,
  perfect_count INT,
  near_count INT,
  miss_count INT,
  health INT,
  modifier INT,
  time_played BIGINT,
  clear_type INT,
  rating DOUBLE,
  favorite_character INT,
  max_stamina_notification_enabled TINYINT,
  current_map TEXT,
  ticket INT,
  prog_boost INT,
  email VARCHAR(255),
  world_rank_score INT,
  ban_flag TEXT,
  next_fragstam_ts BIGINT,
  max_stamina_ts BIGINT,
  stamina INT,
  world_mode_locked_end_ts BIGINT,
  beyond_boost_gauge DOUBLE DEFAULT 0,
  kanae_stored_prog DOUBLE DEFAULT 0,
  mp_notification_enabled TINYINT DEFAULT 1,
  highest_rating_ptt INT DEFAULT 0,
  insight_state INT DEFAULT 4
);

CREATE TABLE IF NOT EXISTS login (
  access_token TEXT,
  user_id INT,
  login_time BIGINT,
  login_ip TEXT,
  login_device TEXT,
  PRIMARY KEY (access_token (255), user_id)
);

CREATE TABLE IF NOT EXISTS friend (
  user_id_me INT,
  user_id_other INT,
  PRIMARY KEY (user_id_me, user_id_other)
);

CREATE TABLE IF NOT EXISTS best_score (
  user_id INT,
  song_id VARCHAR(255),
  difficulty INT,
  score INT,
  shiny_perfect_count INT,
  perfect_count INT,
  near_count INT,
  miss_count INT,
  health INT,
  modifier INT,
  time_played BIGINT,
  best_clear_type INT,
  clear_type INT,
  rating DOUBLE DEFAULT 0,
  score_v2 DOUBLE DEFAULT 0,
  PRIMARY KEY (user_id, song_id, difficulty)
);

CREATE TABLE IF NOT EXISTS user_char (
  user_id INT,
  character_id INT,
  level INT,
  exp DOUBLE,
  is_uncapped TINYINT,
  is_uncapped_override TINYINT,
  skill_flag INT,
  PRIMARY KEY (user_id, character_id)
);

CREATE TABLE IF NOT EXISTS user_char_full (
  user_id INT,
  character_id INT,
  level INT,
  exp DOUBLE,
  is_uncapped TINYINT,
  is_uncapped_override TINYINT,
  skill_flag INT,
  PRIMARY KEY (user_id, character_id)
);

CREATE TABLE IF NOT EXISTS `character` (
  character_id INT PRIMARY KEY,
  name TEXT,
  max_level INT,
  frag1 DOUBLE,
  prog1 DOUBLE,
  overdrive1 DOUBLE,
  frag20 DOUBLE,
  prog20 DOUBLE,
  overdrive20 DOUBLE,
  frag30 DOUBLE,
  prog30 DOUBLE,
  overdrive30 DOUBLE,
  skill_id TEXT,
  skill_unlock_level INT,
  skill_requires_uncap TINYINT,
  skill_id_uncap TEXT,
  char_type INT,
  is_uncapped TINYINT
);

CREATE TABLE IF NOT EXISTS char_item (
  character_id INT,
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (character_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS recent30 (
  user_id INT,
  r_index INT,
  time_played BIGINT,
  song_id VARCHAR(255),
  difficulty INT,
  score INT DEFAULT 0,
  shiny_perfect_count INT DEFAULT 0,
  perfect_count INT DEFAULT 0,
  near_count INT DEFAULT 0,
  miss_count INT DEFAULT 0,
  health INT DEFAULT 0,
  modifier INT DEFAULT 0,
  clear_type INT DEFAULT 0,
  rating DOUBLE DEFAULT 0,
  PRIMARY KEY (user_id, r_index)
);

CREATE TABLE IF NOT EXISTS user_world (
  user_id INT,
  map_id VARCHAR(255),
  curr_position INT,
  curr_capture DOUBLE,
  is_locked TINYINT,
  PRIMARY KEY (user_id, map_id)
);

CREATE TABLE IF NOT EXISTS songplay_token (
  token VARCHAR(255) PRIMARY KEY,
  user_id INT,
  song_id VARCHAR(255),
  difficulty INT,
  course_id VARCHAR(255),
  course_state INT,
  course_score INT,
  course_clear_type INT,
  stamina_multiply INT,
  fragment_multiply INT,
  prog_boost_multiply INT,
  beyond_boost_gauge_usage INT,
  skill_cytusii_flag TEXT,
  skill_chinatsu_flag TEXT,
  invasion_flag INT
);

CREATE TABLE IF NOT EXISTS item (
  item_id VARCHAR(255),
  type VARCHAR(255),
  is_available TINYINT,
  PRIMARY KEY (item_id, type)
);

CREATE TABLE IF NOT EXISTS user_item (
  user_id INT,
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (user_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS purchase (
  purchase_name VARCHAR(255) PRIMARY KEY,
  price INT,
  orig_price INT,
  discount_from BIGINT,
  discount_to BIGINT,
  discount_reason TEXT
);

CREATE TABLE IF NOT EXISTS purchase_item (
  purchase_name VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (purchase_name, item_id, type)
);

CREATE TABLE IF NOT EXISTS user_save (
  user_id INT PRIMARY KEY,
  scores_data TEXT,
  clearlamps_data TEXT,
  clearedsongs_data TEXT,
  unlocklist_data TEXT,
  installid_data TEXT,
  devicemodelname_data TEXT,
  story_data TEXT,
  createdAt BIGINT,
  finalestate_data TEXT
);

CREATE TABLE IF NOT EXISTS present (
  present_id VARCHAR(255) PRIMARY KEY,
  expire_ts BIGINT,
  description TEXT
);

CREATE TABLE IF NOT EXISTS user_present (
  user_id INT,
  present_id VARCHAR(255),
  PRIMARY KEY (user_id, present_id)
);

CREATE TABLE IF NOT EXISTS present_item (
  present_id VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (present_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS chart (
  song_id VARCHAR(255) PRIMARY KEY,
  name TEXT,
  rating_pst INT DEFAULT -1,
  rating_prs INT DEFAULT -1,
  rating_ftr INT DEFAULT -1,
  rating_byn INT DEFAULT -1,
  rating_etr INT DEFAULT -1
);

CREATE TABLE IF NOT EXISTS redeem (code VARCHAR(255) PRIMARY KEY, type INT);

CREATE TABLE IF NOT EXISTS user_redeem (
  user_id INT,
  code VARCHAR(255),
  PRIMARY KEY (user_id, code)
);

CREATE TABLE IF NOT EXISTS redeem_item (
  code VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (code, item_id, type)
);

CREATE TABLE IF NOT EXISTS role (role_id VARCHAR(255) PRIMARY KEY, caption TEXT);

CREATE TABLE IF NOT EXISTS user_role (
  user_id INT,
  role_id VARCHAR(255),
  PRIMARY KEY (user_id, role_id)
);

CREATE TABLE IF NOT EXISTS power(power_id VARCHAR(255) PRIMARY KEY, caption TEXT);

CREATE TABLE IF NOT EXISTS role_power (
  role_id VARCHAR(255),
  power_id VARCHAR(255),
  PRIMARY KEY (role_id, power_id)
);

CREATE TABLE IF NOT EXISTS api_login (
  user_id INT,
  token VARCHAR(255),
  login_time BIGINT,
  login_ip TEXT,
  PRIMARY KEY (user_id, token)
);

CREATE TABLE IF NOT EXISTS course (
  course_id VARCHAR(255) PRIMARY KEY,
  course_name TEXT,
  dan_name TEXT,
  style INT,
  gauge_requirement TEXT,
  flag_as_hidden_when_requirements_not_met TINYINT,
  can_start TINYINT
);

CREATE TABLE IF NOT EXISTS user_course (
  user_id INT,
  course_id VARCHAR(255),
  high_score INT,
  best_clear_type INT,
  PRIMARY KEY (user_id, course_id)
);

CREATE TABLE IF NOT EXISTS course_chart (
  course_id VARCHAR(255),
  song_id VARCHAR(255),
  difficulty INT,
  flag_as_hidden TINYINT,
  song_index INT,
  PRIMARY KEY (course_id, song_index)
);

CREATE TABLE IF NOT EXISTS course_requirement (
  course_id VARCHAR(255),
  required_id VARCHAR(255),
  PRIMARY KEY (course_id, required_id)
);

CREATE TABLE IF NOT EXISTS course_item (
  course_id VARCHAR(255),
  item_id VARCHAR(255),
  type VARCHAR(255),
  amount INT,
  PRIMARY KEY (course_id, item_id, type)
);

CREATE TABLE IF NOT EXISTS user_mission (
  user_id INT,
  mission_id VARCHAR(255),
  status INT,
  PRIMARY KEY (user_id, mission_id)
);

CREATE TABLE IF NOT EXISTS user_kvdata (
  user_id INT,
  class VARCHAR(255),
  `key` VARCHAR(255),
  idx INT,
  value TEXT,
  PRIMARY KEY (user_id, class, `key`, idx)
);

CREATE INDEX IF NOT EXISTS best_score_1 ON best_score (song_id, difficulty);

CREATE TABLE IF NOT EXISTS user_custom_course (
  user_id INT,
  custom_course TEXT,
  PRIMARY KEY (user_id)
);

CREATE TABLE IF NOT EXISTS download_token (
  user_id INT,
  song_id VARCHAR(255),
  file_name VARCHAR(255),
  token VARCHAR(255),
  time BIGINT,
  PRIMARY KEY (user_id, song_id, file_name)
);

-- Add notification and bundle download tables
CREATE TABLE IF NOT EXISTS notification (
  user_id INT,
  id INT,
  type VARCHAR(255),
  content TEXT,
  sender_user_id INT,
  sender_name VARCHAR(255),
  timestamp BIGINT,
  PRIMARY KEY (user_id, id)
);

CREATE TABLE IF NOT EXISTS bundle_download_token (
  token VARCHAR(255) PRIMARY KEY,
  file_path TEXT,
  time BIGINT,
  device_id VARCHAR(255)
);
这是所有数据库接口，你无需再阅读现有的数据库迁移。

下面是我需要你帮我实现的目标：

我已经初步实现 core 文件夹下的 others， user，download ，character 和 score 模块。 目前 others 中的 aggregate 函数已经简单的实现了接口，但是具体内容还没完全实现。python 版本是真实可用的，并且aggregate返回的 json 我已经放在 py_version/resp.json 中。由于这个 json 非常长，因此直接读取不太可行，你可以通过 jq 来获取你需要的信息。我希望你阅读对应的模块，帮我实现缺失的部分，并且补充现在 rust 代码中的 todo 为真实实现。而 rust 返回的信息在同一个文件夹下的 resp_rs.json，你可以对比缺失的部分，帮我实现具体的逻辑。另外我希望你先完成这样的任务：python 版本会自动把一些游戏基础数据写入数据库（在 py_version/database/init/下面有不少的 json 是游戏元数据，这些内容会在服务器启动时写入数据库，你需要查看怎么读取这些数据，怎么写入数据库，并复制这些 json 以及元数据到我 rust 合适的位置），我希望你读取它的实现，并在我的 rust 中实现这个功能，使用你认为适合 sqlx 的正确方法来实现这个任务。
